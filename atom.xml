<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ITest</title>
  
  <subtitle>我的测试空间</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-01-04T08:13:29.807Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>chu kun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jvm-sandbox-mock</title>
    <link href="http://yoursite.com/2021/01/04/jvm-sandbox-mock/"/>
    <id>http://yoursite.com/2021/01/04/jvm-sandbox-mock/</id>
    <published>2021-01-04T08:13:01.734Z</published>
    <updated>2021-01-04T08:13:29.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="troublemaker-捣蛋鬼"><a href="#troublemaker-捣蛋鬼" class="headerlink" title="troublemaker  (捣蛋鬼)"></a>troublemaker  (捣蛋鬼)</h1><h4 id="这是一个mock服务管理后台，包含用户（接入的应用）、配置（应用mock规则配置）功能"><a href="#这是一个mock服务管理后台，包含用户（接入的应用）、配置（应用mock规则配置）功能" class="headerlink" title="这是一个mock服务管理后台，包含用户（接入的应用）、配置（应用mock规则配置）功能"></a>这是一个mock服务管理后台，包含用户（接入的应用）、配置（应用mock规则配置）功能</h4><ul><li>使用该mock平台需要在应用端安装 mock client，安装步骤</li></ul><h3 id="第一步（安装）"><a href="#第一步（安装）" class="headerlink" title="第一步（安装）"></a>第一步（安装）</h3><ol><li>配置应用jvm环境变量</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dmock.host&#x3D;http:&#x2F;&#x2F;10.250.10.6:8003 -Dapp.name&#x3D;hsc -Dapp.env&#x3D;20201207-daily-zejun</span><br></pre></td></tr></table></figure><ol start="2"><li>启动应用后安装mock client<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://kunchu.oss-cn-beijing.aliyuncs.com/install-troublemaker.sh |sh</span><br></pre></td></tr></table></figure></li><li>启动mock client （默认启动 48 pid  如果不是 需要手动启动）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">jps 通过jps找到应用的 pid  比如 pid 为 49</span><br><span class="line">.&#x2F;sandbox&#x2F;bin&#x2F;sandbox.sh -p 49</span><br></pre></td></tr></table></figure><ol start="4"><li>如果启动成功，就可以在mock平台查看到自己应用的用户已经在运行中了</li></ol><h3 id="第二步（配置mock）"><a href="#第二步（配置mock）" class="headerlink" title="第二步（配置mock）"></a>第二步（配置mock）</h3><p><img src="https://kunchu.oss-cn-beijing.aliyuncs.com/image/create.png" alt="image"></p><ol><li>选择需要mock的应用及环境</li><li>配置需要mock的类名及方法名 （Interface类不支持）</li><li>配置这个方法需要的返回</li></ol><ul><li><p>如果返回的是基本类型，直接在returnData里返回（比如布尔类型返回false）例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  classNames: [</span><br><span class="line">  ],</span><br><span class="line">  returnData: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果返回的是简单对象  例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  classNames: [</span><br><span class="line">    &#39;com.ytgw.facade.message.SupergwMessage&#39;</span><br><span class="line">  ],</span><br><span class="line">  returnData: &#123;</span><br><span class="line">    businessResultCode: &#39;SUCCESS1&#39;,</span><br><span class="line">    channelResponseCode: &#39;0&#39;,</span><br><span class="line">    channelResponseMessage: &#39;校验成功&#39;,</span><br><span class="line">    channelResponseType: &#39;SUCCESS&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      name: &#39;message&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果返回的是嵌套对象 例如：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  classNames: [</span><br><span class="line">    &#39;com.tester.jvm.mock.common.domain.MockResult&#39;,&#x2F;&#x2F;这里需要按照类型从外到内排序（MockResult&lt;String&gt;）</span><br><span class="line">    &#39;java.lang.String&#39;</span><br><span class="line">  ],</span><br><span class="line">  returnData: &#123;</span><br><span class="line">    success: true,</span><br><span class="line">    data: &#39;ccccccc&#39;,</span><br><span class="line">    message: &#39;获取成功&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;troublemaker-捣蛋鬼&quot;&gt;&lt;a href=&quot;#troublemaker-捣蛋鬼&quot; class=&quot;headerlink&quot; title=&quot;troublemaker  (捣蛋鬼)&quot;&gt;&lt;/a&gt;troublemaker  (捣蛋鬼)&lt;/h1&gt;&lt;h4 id=&quot;这是一
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>jacoco</title>
    <link href="http://yoursite.com/2020/12/23/jacoco/"/>
    <id>http://yoursite.com/2020/12/23/jacoco/</id>
    <published>2020-12-23T12:40:30.600Z</published>
    <updated>2020-12-23T13:09:47.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jacoco"><a href="#jacoco" class="headerlink" title="jacoco"></a>jacoco</h1><h5 id="java启动参数"><a href="#java启动参数" class="headerlink" title="java启动参数"></a>java启动参数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:&#x2F;Users&#x2F;pro9q&#x2F;software&#x2F;jacoco-0.8.6&#x2F;lib&#x2F;jacocoagent.jar&#x3D;includes&#x3D;*,output&#x3D;tcpserver,port&#x3D;6300,address&#x3D;localhost,append&#x3D;true</span><br></pre></td></tr></table></figure><h5 id="获取文件到本地"><a href="#获取文件到本地" class="headerlink" title="获取文件到本地"></a>获取文件到本地</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar jacoco-0.8.6&#x2F;lib&#x2F;jacococli.jar  dump --address localhost --port 6300 --destfile jacoco-data&#x2F;jacoco-demo.exec</span><br></pre></td></tr></table></figure><h5 id="生成覆盖率文件"><a href="#生成覆盖率文件" class="headerlink" title="生成覆盖率文件"></a>生成覆盖率文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar jacoco-0.8.6&#x2F;lib&#x2F;jacococli.jar report jacoco-data&#x2F;jacoco-demo.exec --classfiles &#x2F;Users&#x2F;pro9q&#x2F;IdeaProjects&#x2F;jvm-sandbox-mock&#x2F;mock-web&#x2F;target --sourcefiles  &#x2F;Users&#x2F;pro9q&#x2F;IdeaProjects&#x2F;jvm-sandbox-mock&#x2F;mock-web&#x2F;src&#x2F;main&#x2F;java --html jacoco-data&#x2F;report1 --xml jacoco-data&#x2F;report.xml</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jacoco&quot;&gt;&lt;a href=&quot;#jacoco&quot; class=&quot;headerlink&quot; title=&quot;jacoco&quot;&gt;&lt;/a&gt;jacoco&lt;/h1&gt;&lt;h5 id=&quot;java启动参数&quot;&gt;&lt;a href=&quot;#java启动参数&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>STF平台搭建</title>
    <link href="http://yoursite.com/2020/12/23/STF%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/12/23/STF%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/</id>
    <published>2020-12-23T12:34:01.009Z</published>
    <updated>2021-03-11T07:17:27.854Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方式一-源码安装"><a href="#方式一-源码安装" class="headerlink" title="方式一  源码安装"></a>方式一  源码安装</h3><h4 id="一、下载stf源码"><a href="#一、下载stf源码" class="headerlink" title="一、下载stf源码"></a>一、下载stf源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">地址  : https:&#x2F;&#x2F;github.com&#x2F;openstf&#x2F;stf</span><br></pre></td></tr></table></figure><h4 id="二、-进入源码目录安装，命令如下"><a href="#二、-进入源码目录安装，命令如下" class="headerlink" title="二、 进入源码目录安装，命令如下"></a>二、 进入源码目录安装，命令如下</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>此时可能会报错：bower EINVRES Request to <a href="https://bower.herokuapp.com/packages/font-awesome" target="_blank" rel="noopener">https://bower.herokuapp.com/packages/font-awesome</a> failed with 502<br>此Bower版本已弃用。请更新它：npm install -g bower。新的注册地址是<a href="https://registry.bower.io" target="_blank" rel="noopener">https://registry.bower.io</a><br>将bower升级到最新版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g bower</span><br></pre></td></tr></table></figure><h4 id="三、-安装后link全局方式"><a href="#三、-安装后link全局方式" class="headerlink" title="三、 安装后link全局方式"></a>三、 安装后link全局方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link</span><br></pre></td></tr></table></figure><h4 id="四、检查安装组件是否符合要求"><a href="#四、检查安装组件是否符合要求" class="headerlink" title="四、检查安装组件是否符合要求"></a>四、检查安装组件是否符合要求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sft doctor</span><br></pre></td></tr></table></figure><p>此时可能报错 版本不一致 ，根据版本提示修改相应版本即可。</p><h4 id="五、运行准备"><a href="#五、运行准备" class="headerlink" title="五、运行准备"></a>五、运行准备</h4><p>启动数据库  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rethinkdb</span><br></pre></td></tr></table></figure><h4 id="六、启动STF"><a href="#六、启动STF" class="headerlink" title="六、启动STF"></a>六、启动STF</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stf local --public-ip &lt;ip address&gt;</span><br></pre></td></tr></table></figure><h3 id="第二种-docker安装方式"><a href="#第二种-docker安装方式" class="headerlink" title="第二种 docker安装方式"></a>第二种 docker安装方式</h3><h4 id="1-安装docker"><a href="#1-安装docker" class="headerlink" title="1.安装docker"></a>1.安装docker</h4><p>详见官方文档</p><h4 id="2-拉去镜像"><a href="#2-拉去镜像" class="headerlink" title="2.拉去镜像"></a>2.拉去镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull openstf&#x2F;stf:latest # STF镜像</span><br><span class="line">sudo docker pull sorccu&#x2F;adb:latest # android adb 镜像</span><br><span class="line">sudo docker pull rethinkdb:latest # rethinkdb 镜像</span><br><span class="line">sudo docker pull openstf&#x2F;ambassador:latest</span><br><span class="line">sudo docker pull nginx:latest # nginx代理镜像</span><br></pre></td></tr></table></figure><h4 id="3-检查镜像"><a href="#3-检查镜像" class="headerlink" title="3.检查镜像"></a>3.检查镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure><h4 id="4-启动镜像"><a href="#4-启动镜像" class="headerlink" title="4.启动镜像"></a>4.启动镜像</h4><p>linux 系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- docker run -d --name rethinkdb -v &#x2F;srv&#x2F;rethinkdb:&#x2F;data --net host rethinkdb rethinkdb --bind all --cache-size 8192 --http-port 8090</span><br><span class="line">- docker run -d --name adbd --privileged -v &#x2F;dev&#x2F;bus&#x2F;usb:&#x2F;dev&#x2F;bus&#x2F;usb --net host sorccu&#x2F;adb:latest</span><br><span class="line">- docker run -d --name stf --net host openstf&#x2F;stf stf local --public-ip &lt;your-ip&gt;</span><br><span class="line">- docker ps -a</span><br></pre></td></tr></table></figure><p>Mac 系统  （–net host 在mac中不好使  所以使用–net=container:）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- docker run -d --name rethinkdb -v &#x2F;srv&#x2F;rethinkdb:&#x2F;data -p 7100:7100 -p 8090:8090 rethinkdb rethinkdb --bind all --cache-size 8192 --http-port 8090</span><br><span class="line">- docker run -d --name adbd --privileged -v &#x2F;dev&#x2F;bus&#x2F;usb:&#x2F;dev&#x2F;bus&#x2F;usb --net&#x3D;container:$&#123;container_id&#125;  sorccu&#x2F;adb:latest</span><br><span class="line">- docker run -d --name stf  --net&#x3D;container:$&#123;container_id&#125; openstf&#x2F;stf stf local --public-ip &lt;your-ip&gt;</span><br><span class="line">- docker ps -a</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;方式一-源码安装&quot;&gt;&lt;a href=&quot;#方式一-源码安装&quot; class=&quot;headerlink&quot; title=&quot;方式一  源码安装&quot;&gt;&lt;/a&gt;方式一  源码安装&lt;/h3&gt;&lt;h4 id=&quot;一、下载stf源码&quot;&gt;&lt;a href=&quot;#一、下载stf源码&quot; class=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/12/23/hello-world/"/>
    <id>http://yoursite.com/2020/12/23/hello-world/</id>
    <published>2020-12-23T12:34:01.009Z</published>
    <updated>2020-12-23T12:34:01.009Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>jmeter-java请求-dubbo</title>
    <link href="http://yoursite.com/2020/12/23/jmeter-java%E8%AF%B7%E6%B1%82-dubbo/"/>
    <id>http://yoursite.com/2020/12/23/jmeter-java%E8%AF%B7%E6%B1%82-dubbo/</id>
    <published>2020-12-23T12:34:01.009Z</published>
    <updated>2020-12-23T12:34:01.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dubbo-接口压力测试脚本编写"><a href="#dubbo-接口压力测试脚本编写" class="headerlink" title="dubbo 接口压力测试脚本编写"></a>dubbo 接口压力测试脚本编写</h1><h2 id="一、创建maven工程"><a href="#一、创建maven工程" class="headerlink" title="一、创建maven工程"></a>一、创建maven工程</h2><blockquote><p>pom.xml里导入jmeter依赖及相应服务的依赖</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.jmeter&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;ApacheJMeter_java&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.jmeter&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;ApacheJMeter_core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="二、编写dubbo连接class-DubboSampleClient"><a href="#二、编写dubbo连接class-DubboSampleClient" class="headerlink" title="二、编写dubbo连接class DubboSampleClient"></a>二、编写dubbo连接class DubboSampleClient</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">package dubbo;</span><br><span class="line"></span><br><span class="line">import com.alibaba.dubbo.config.ApplicationConfig;</span><br><span class="line">import com.alibaba.dubbo.config.ReferenceConfig;</span><br><span class="line">import com.alibaba.dubbo.config.RegistryConfig;</span><br><span class="line">import com.alibaba.dubbo.config.utils.ReferenceConfigCache;</span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import org.apache.jmeter.config.Arguments;</span><br><span class="line">import org.apache.jmeter.protocol.java.sampler.AbstractJavaSamplerClient;</span><br><span class="line">import org.apache.jmeter.protocol.java.sampler.JavaSamplerContext;</span><br><span class="line">import org.apache.jmeter.samplers.SampleResult;</span><br><span class="line">import org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.ParameterizedType;</span><br><span class="line">import java.lang.reflect.Type;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 基类 Created by binli on 2015-12-15.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public abstract class DubboSampleClient&lt;T&gt; extends AbstractJavaSamplerClient &#123;</span><br><span class="line">private static Logger logger &#x3D; Logger.getLogger(DubboSampleClient.class);</span><br><span class="line">&#x2F;**</span><br><span class="line"> * privider实例</span><br><span class="line"> *&#x2F;</span><br><span class="line">private T instance;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected String getInterfaceName() &#123;</span><br><span class="line">String interfaceName &#x3D; getSuperClassGenricType(getClass(), 0).getName();</span><br><span class="line">System.out.println(interfaceName);</span><br><span class="line">return interfaceName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 拿到provider的实例</span><br><span class="line"> * </span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected T getInstance() &#123;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 初始化test</span><br><span class="line"> * </span><br><span class="line"> * @param context</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public void setupTest(JavaSamplerContext context) &#123;</span><br><span class="line">super.setupTest(context);</span><br><span class="line">&#x2F;&#x2F; 当前应用配置</span><br><span class="line">ApplicationConfig application &#x3D; new ApplicationConfig();</span><br><span class="line">application.setName(context.getParameter(&quot;consumerName1&quot;, &quot;jmeter-dubbo-test1&quot;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 连接注册中心配置</span><br><span class="line">RegistryConfig registry &#x3D; new RegistryConfig();</span><br><span class="line">registry.setAddress(context.getParameter(&quot;zkAddress&quot;,</span><br><span class="line">&quot;zktestserver1.wacai.info:22181,zktestserver2.wacai.info:22181,zktestserver3.wacai.info:22181&quot;));</span><br><span class="line">registry.setGroup(context.getParameter(&quot;dubboGroup&quot;, &quot;dubbo_test&quot;));</span><br><span class="line">registry.setProtocol(&quot;zookeeper&quot;);</span><br><span class="line">registry.setClient(&quot;zkclient&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 注意：ReferenceConfig为重对象，内部封装了与注册中心的连接，以及与服务提供方的连接</span><br><span class="line"> * 此实例很重，封装了与注册中心的连接以及与提供者的连接，请自行缓存，否则可能造成内存和连接泄漏</span><br><span class="line"> *&#x2F;</span><br><span class="line">ReferenceConfig&lt;T&gt; reference &#x3D; new ReferenceConfig&lt;T&gt;(); reference.setApplication(application);</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 多个注册中心可以用setRegistries()</span><br><span class="line"> * *&#x2F;</span><br><span class="line"></span><br><span class="line">reference.setRegistry(registry);</span><br><span class="line">reference.setInterface(getInterfaceName());</span><br><span class="line">reference.setTimeout(50000);</span><br><span class="line">reference.setUrl(context.getParameter(&quot;url&quot;));</span><br><span class="line">String version &#x3D; context.getParameter(&quot;version&quot;);</span><br><span class="line">if(null!&#x3D;version&amp;&amp;!&quot;&quot;.equals(version))&#123;</span><br><span class="line">reference.setVersion(&quot;3.0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">String zkAddress &#x3D; context.getParameter(&quot;zkAddress&quot;);</span><br><span class="line">if (null !&#x3D; zkAddress) &#123;</span><br><span class="line">if (zkAddress.startsWith(&quot;dubbo&quot;)) &#123;</span><br><span class="line">reference.setUrl(context.getParameter(&quot;zkAddress&quot;));</span><br><span class="line">&#125;</span><br><span class="line">ReferenceConfigCache cache &#x3D; ReferenceConfigCache.getCache();</span><br><span class="line">instance &#x3D; cache.get(reference);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 返回给jmeter默认可设置的参数</span><br><span class="line"> * </span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public Arguments getDefaultParameters() &#123;</span><br><span class="line">Arguments args &#x3D; new Arguments();</span><br><span class="line">args.addArgument(&quot;consumerName&quot;, &quot;jmeter-dubbo-test&quot;);</span><br><span class="line">args.addArgument(&quot;dubboGroup&quot;, &quot;dubbo_test&quot;);</span><br><span class="line">args.addArgument(&quot;url&quot;, &quot;&quot;);</span><br><span class="line">args.addArgument(&quot;zkAddress&quot;,</span><br><span class="line">&quot;zktestserver1.wacai.info:22181,zktestserver2.wacai.info:22181,zktestserver3.wacai.info:22181&quot;);</span><br><span class="line">return args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 获得泛型</span><br><span class="line"> * </span><br><span class="line"> * @param clazz</span><br><span class="line"> * @param index</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">private Class&lt;Object&gt; getSuperClassGenricType(final Class clazz, final int index) &#123;</span><br><span class="line"></span><br><span class="line">Type genType &#x3D; clazz.getGenericSuperclass();</span><br><span class="line"></span><br><span class="line">if (!(genType instanceof ParameterizedType)) &#123;</span><br><span class="line">return Object.class;</span><br><span class="line">&#125;</span><br><span class="line">Type[] params &#x3D; ((ParameterizedType) genType).getActualTypeArguments();</span><br><span class="line"></span><br><span class="line">if (index &gt;&#x3D; params.length || index &lt; 0) &#123;</span><br><span class="line">return Object.class;</span><br><span class="line">&#125;</span><br><span class="line">if (!(params[index] instanceof Class)) &#123;</span><br><span class="line">return Object.class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return (Class) params[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public SampleResult sampleRun(JavaSamplerContext jsc, Action a) &#123;</span><br><span class="line">SampleResult result &#x3D; new SampleResult();</span><br><span class="line">result.sampleStart(); &#x2F;&#x2F; start stopwatch</span><br><span class="line">Object res &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">res &#x3D; a.preform();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">&#x2F;&#x2F; e.printStackTrace();</span><br><span class="line">logger.error(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(JSON.toJSON(res));</span><br><span class="line">logger.info(&quot;res-----:&quot;+JSON.toJSON(res));</span><br><span class="line">if (null !&#x3D; res) &#123;</span><br><span class="line">result.sampleEnd(); &#x2F;&#x2F; stop stopwatch</span><br><span class="line">result.setSuccessful(true);</span><br><span class="line">result.setResponseData(JSON.toJSONString(res), &quot;utf-8&quot;);</span><br><span class="line">result.setResponseMessage(JSON.toJSONString(res));</span><br><span class="line">result.setResponseCodeOK(); &#x2F;&#x2F; 200 code</span><br><span class="line">&#125; else &#123;</span><br><span class="line">result.sampleEnd(); &#x2F;&#x2F; stop stopwatch</span><br><span class="line">result.setSuccessful(false);</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * The Action Class is for making the Demo View Custom Code</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface Action &#123;</span><br><span class="line">public Object preform();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>DubboSampleClient 类对dubbo连接做了封装  dubbo参数要在这里配置，此类在测试项目中有介绍，这里不过多描述。</p></blockquote><h2 id="三、编写测试class"><a href="#三、编写测试class" class="headerlink" title="三、编写测试class"></a>三、编写测试class</h2><blockquote><p>public class PushByPushIdTest extends DubboSampleClient<PushService>{方法体} 该类必须继承DubboSampleClient（）</p></blockquote><ul><li>1、编写界面参数  命名固定为getDefaultParameters（）方法<blockquote><p>参数类型全部为string类型，如果后面要用其他类型参数传入，此时需要转换。</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> public Arguments getDefaultParameters() &#123;</span><br><span class="line">    Arguments args &#x3D;  super.getDefaultParameters();</span><br><span class="line">    &#x2F;&#x2F;此处请添加你们需要动态变化的参数</span><br><span class="line">    args.addArgument(&quot;pushId&quot;, &quot;abde7537e79039b72cea2e340ecdeb10&quot;);</span><br><span class="line">    args.addArgument(&quot;content&quot;,&quot;byPushId 压力测试&quot;);</span><br><span class="line">    args.addArgument(&quot;url&quot;,&quot;&quot;);</span><br><span class="line">    return args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2、编写数据处理逻辑  <blockquote><p>命名固定为runTest(JavaSamplerContext jsc)方法 并且要有类型为SampleResult返回值。</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public SampleResult  runTest(JavaSamplerContext jsc) &#123;</span><br><span class="line">        SampleResult sr &#x3D; new SampleResult();</span><br><span class="line">        return super.sampleRun(jsc, ()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;Sample 开始   记录开始时间</span><br><span class="line">                sr.sampleStart();</span><br><span class="line">                RequestParam requestParam &#x3D; new RequestParam();</span><br><span class="line">                requestParam.setAppName(&quot;wcb&quot;);</span><br><span class="line">                requestParam.setExpiredTime(1L);</span><br><span class="line">                String plat &#x3D; jsc.getParameter(&quot;platforms&quot;);</span><br><span class="line">                &#x2F;将传入的string类型转成list</span><br><span class="line">                List&lt;Integer&gt; listplat &#x3D; Arrays.asList(plat.split(&quot;,&quot;))</span><br><span class="line">                        .stream().map(s -&gt; Integer.parseInt(s.trim()))</span><br><span class="line">                        .collect(Collectors.toList());</span><br><span class="line">                requestParam.setPlatforms(listplat);</span><br><span class="line">                requestParam.setPushId(jsc.getParameter(&quot;pushId&quot;));</span><br><span class="line">                requestParam.setContent(jsc.getParameter(&quot;content&quot;));</span><br><span class="line">                int mt &#x3D; requestParam.setMsgType(mt);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                Response&lt;ErrorCode&gt; result &#x3D; getInstance().pushByPushId(requestParam);</span><br><span class="line">                sr.setSamplerData(result.getValue().getReason());</span><br><span class="line">                sr.setSuccessful(true);</span><br><span class="line"></span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                sr.getResponseData();</span><br><span class="line">                sr.setSuccessful(false);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line"></span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">                sr.sampleEnd();</span><br><span class="line">            &#125;</span><br><span class="line">            return sr;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="四、main函数检查可行性（压测中此方法不是必要条件，主要用来检测）"><a href="#四、main函数检查可行性（压测中此方法不是必要条件，主要用来检测）" class="headerlink" title="四、main函数检查可行性（压测中此方法不是必要条件，主要用来检测）"></a>四、main函数检查可行性（压测中此方法不是必要条件，主要用来检测）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">       Arguments argss &#x3D; new Arguments();</span><br><span class="line">       argss.addArgument(&quot;pushId&quot;, &quot;abde7537e79039b72cea2e340ecdeb10&quot;);</span><br><span class="line">       argss.addArgument(&quot;content&quot;,&quot;byPushId 压力测试&quot;);</span><br><span class="line">       argss.addArgument(&quot;url&quot;,&quot;www.baidu.com&quot;);</span><br><span class="line">       argss.addArgument(&quot;title&quot;,&quot;title 测试&quot;);</span><br><span class="line">       argss.addArgument(&quot;platforms&quot;,&quot;41&quot;);</span><br><span class="line">       argss.addArgument(&quot;msgType&quot;,&quot;1&quot;);</span><br><span class="line">       argss.addArgument(&quot;zkAddress&quot;,</span><br><span class="line">               &quot;zktestserver1.wacai.info:22181,zktestserver2.wacai.info:22181,zktestserver3.wacai.info:22181&quot;);</span><br><span class="line">       JavaSamplerContext jsc &#x3D; new JavaSamplerContext(argss);</span><br><span class="line">       PushByPushIdTest bqe &#x3D; new PushByPushIdTest();</span><br><span class="line">       bqe.setupTest(jsc);</span><br><span class="line">       bqe.runTest(jsc);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="五、jar包导入"><a href="#五、jar包导入" class="headerlink" title="五、jar包导入"></a>五、jar包导入</h2><ul><li>1、打成jar包 ,将打好的项目jar包放在jmeter/lib/ext下。</li><li>2、执行mvn dependency:copy-dependencies下载工程依赖包，targer/dependecies   目录下为所以依赖包，<br>完成后将依赖包全部放在jmeter/lib下 ， 不得和lib已有的包冲突  ，如果冲突，删除所以已有jar包，然后放入所以依赖包。</li><li>3、启动jmeter,   在java请求中理论会有包里的测试class, 没有则检查包及代码。</li></ul><h2 id="测试项目"><a href="#测试项目" class="headerlink" title="测试项目"></a>测试项目</h2><p>此项目只参考去编写，不要使用本项目进行压测</p><blockquote><p><a href="mailto:git@git.caimi-inc.com">git@git.caimi-inc.com</a>:qiuhaitang/jmeterdubbotest.git</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;dubbo-接口压力测试脚本编写&quot;&gt;&lt;a href=&quot;#dubbo-接口压力测试脚本编写&quot; class=&quot;headerlink&quot; title=&quot;dubbo 接口压力测试脚本编写&quot;&gt;&lt;/a&gt;dubbo 接口压力测试脚本编写&lt;/h1&gt;&lt;h2 id=&quot;一、创建maven
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Jmeter压测实时监控</title>
    <link href="http://yoursite.com/2020/12/23/Jmeter%E5%8E%8B%E6%B5%8B%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7/"/>
    <id>http://yoursite.com/2020/12/23/Jmeter%E5%8E%8B%E6%B5%8B%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7/</id>
    <published>2020-12-23T12:34:01.008Z</published>
    <updated>2020-12-23T12:34:01.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>jmeter 在调试脚本时，用的是gui界面，可以通过界面监控插件实时查看数据.但在真实测试中，我们往往用的的是非gui界面，这样可以避免界面对性能测试<br>的影响，此时我们就需求在非gui界面做一些实时监控，这里介绍一种方法满足这个需求。jmeter.Backend Listener + Grafana + InfluxDB</p><h2 id="InfluxDB"><a href="#InfluxDB" class="headerlink" title="InfluxDB"></a>InfluxDB</h2><p>简介：InfluxDB是一个开源的没有外部依赖的时间序列数据库 适用于记录度量，事件及执行分析</p><h3 id="安装InfluxDB"><a href="#安装InfluxDB" class="headerlink" title="安装InfluxDB"></a>安装InfluxDB</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mac    &gt; brew update</span><br><span class="line">          &gt; brew install influxdb</span><br><span class="line">          &gt; ln -sfv &#x2F;usr&#x2F;local&#x2F;opt&#x2F;influxdb&#x2F;*.plist ~&#x2F;Library&#x2F;LaunchAgents</span><br><span class="line">          &gt; launchctl load ~&#x2F;Library&#x2F;LaunchAgents&#x2F;homebrew.mxcl.influxdb.plist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   linux  &gt;wget https:&#x2F;&#x2F;dl.influxdata.com&#x2F;influxdb&#x2F;releases&#x2F;influxdb-0.13.0.x86_64.rpm</span><br><span class="line">          &gt;sudo yum localinstall influxdb-0.13.0.x86_64.rpm</span><br></pre></td></tr></table></figure><p>配置InfluxDB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi &#x2F;etc&#x2F;influxdb&#x2F;influxdb.conf</span><br><span class="line"></span><br><span class="line"># 找到graphite并且修改它的库与端口</span><br><span class="line">[[graphite]]</span><br><span class="line">  enabled &#x3D; true</span><br><span class="line">  database &#x3D; &quot;jmeter&quot;</span><br><span class="line">  bind-address &#x3D; &quot;:2003&quot;</span><br><span class="line">  protocol &#x3D; &quot;tcp&quot;</span><br><span class="line">  consistency-level &#x3D; &quot;one&quot;</span><br><span class="line"></span><br><span class="line"># 找到admin，将前面的#号去掉，开放它的UI端口</span><br><span class="line">[admin]</span><br><span class="line">  # Determines whether the admin service is enabled.</span><br><span class="line">  enabled &#x3D; true</span><br><span class="line"></span><br><span class="line">  # The default bind address used by the admin service.</span><br><span class="line">  bind-address &#x3D; &quot;:8083&quot;</span><br><span class="line"></span><br><span class="line">  # Whether the admin service should use HTTPS.</span><br><span class="line">  # https-enabled &#x3D; false</span><br><span class="line"></span><br><span class="line">  # The SSL certificate used when HTTPS is enabled.</span><br><span class="line">  # https-certificate &#x3D; &quot;&#x2F;etc&#x2F;ssl&#x2F;influxdb.pem</span><br></pre></td></tr></table></figure><p>创建数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; influx</span><br><span class="line">&gt; CREATE DATABASE jmeter</span><br></pre></td></tr></table></figure><p>启动InfluxDB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# &#x2F;etc&#x2F;init.d&#x2F;influxdb restart</span><br><span class="line">Stopping influxdb...</span><br><span class="line">influxdb process was stopped [ OK ]</span><br><span class="line">Starting influxdb...</span><br><span class="line">influxdb process was started [ OK ]</span><br></pre></td></tr></table></figure><p>按配置启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; influxd -config &#x2F;usr&#x2F;local&#x2F;etc&#x2F;influxdb.conf</span><br></pre></td></tr></table></figure><h2 id="Jmeter"><a href="#Jmeter" class="headerlink" title="Jmeter"></a>Jmeter</h2><p>要将性能指标从JMeter推送到InfluxDB，我们需要使用Backend Listener。<br>此侦听器允许将度量标准直接写入数据库。</p><html><img src="https://cdn2.hubspot.net/hubfs/208250/Blog_Images/grafana6.png" width="600" hegiht="300" align=center /></html><p>Backend Listener 参数解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Backend Listener implementation - 这是一个实现类，将用作JMeter测试指标的监听器。此参数的值基于我们将要使用的协议。如果您还记得，我们使用了为InfluxDB配置指定的石墨协议配置。为此，我们需要使用&#39;GraphiteBackendListenerClient&#39;</span><br><span class="line">Async Queue size  - 队列值包含异步处理它们的度量标准。除非有一些特定的性能问题，否则最好不要将此值从默认的“5000”值更改。</span><br><span class="line">graphiteMetricsSender - 将用作度量标准发送方的实现类。只需使用默认值。</span><br><span class="line">graphiteHost - InfluxDB所在的主机</span><br><span class="line">graphitePort - 我们在InfluxDB配置文件的&#39;graphite&#39;部分中指定的端口</span><br><span class="line">rootMetricsPrefix - 将用于存储在数据库中的所有度量标准的基本前缀。请注意，指标没有默认分隔符。这就是为什么最好使用&#39;。&#39; 此属性中指定的前缀末尾的符号</span><br><span class="line">summaryOnly - 如果您只想在数据库中保留摘要结果并且不希望在测试执行期间收集所有详细指标，请使用“true”</span><br><span class="line">samplersList - 如果要仅将特定采样器发送到数据库，请使用此字段。在我们的例子中，我们想要发送所有样本，因此我们将此参数留空</span><br><span class="line">useRegexpForSamplersList - 如果要在&#39;samplersList&#39;字段中指定正则表达式以选择应发送到数据库的采样器，则输入&#39;true&#39;</span><br><span class="line">percentiles - 用于指定应发送到数据库的度量百分位数</span><br></pre></td></tr></table></figure><p>一旦配置到位，我们就可以运行我们的测试执行。</p><p>查看InfluxDB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; influx</span><br><span class="line">&gt; USE jmeter</span><br><span class="line">&gt; SHOW MEASUREMENTS</span><br><span class="line">&gt; SELECT * FROM &quot;jmeter.all.a.avg&quot;   &#x2F;&#x2F; 有数据则连接数据库成功</span><br></pre></td></tr></table></figure><p>常用参数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">名称                           描述</span><br><span class="line">jmeter.all.h.count        所有请求的TPS</span><br><span class="line">jmeter.&lt;请求名称&gt;.h.count对应&lt;请求名称&gt;的TPS</span><br><span class="line">jmeter.all.ok.pct99        99%的请求响应时间</span><br><span class="line">jmeter.&lt;请求名称&gt;.ok.pct99对应&lt;请求名称&gt;99%的请求响应时间</span><br><span class="line">jmeter.all.test.startedT线程数</span><br></pre></td></tr></table></figure><html><img src="http://git.caimi-inc.com/Platform/basic-biz-service/uploads/e38af0d2c0db0960dd546b966ea886d3/image.png" width="600" hegiht="300" align=center /></html><h2 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h2><p>安装 Grafana</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mac      &gt; brew install grafana</span><br><span class="line">linux    &gt; yum install https:&#x2F;&#x2F;s3-us-west-2.amazonaws.com&#x2F;grafana-releases&#x2F;release&#x2F;grafana-4.4.3-1.x86_64.rpm</span><br></pre></td></tr></table></figure><p>启动 Grafana</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; service grafana-server start</span><br></pre></td></tr></table></figure><p>登录 Grafana</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">默认用3000端口  例如 本地用 http:&#x2F;&#x2F;localhost:3000</span><br><span class="line">使用“admin”作为默认用户名和密码登录</span><br></pre></td></tr></table></figure><html><img src="https://cdn2.hubspot.net/hubfs/208250/Blog_Images/grafana8.png" width="600" hegiht="300" align=center /></html><p>首先，我们需要使用指标指定数据源。点击欢迎页面上的“Add data source”</p><html><img src="https://cdn2.hubspot.net/hubfs/208250/Blog_Images/grafana9.png" width="600" hegiht="300" align=center /></html><p>根据我们之前的步骤进行适当的配置,然后单击“添加”按钮以验证Grafana是否可以连接到InfluxDB</p><html><img src="https://cdn2.hubspot.net/hubfs/208250/Blog_Images/grafana10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" width="600" hegiht="300" align=center /></html><p>在Grafana中创建我们的第一个仪表板。单击左上角的按钮打开Grafana菜单，然后转到Dashboards -&gt; New</p><html><img src="https://cdn2.hubspot.net/hubfs/208250/Blog_Images/grafana11.png" width="600" hegiht="300" align=center /></html><p>Grafana从JMeter收集了InfluxDB中的数据。通过单击每行的顶部，您可以选择该行应表示的度量标准。</p><html><img src="http://git.caimi-inc.com/Platform/basic-biz-service/uploads/8090dc216e33e6d8fd25db715bfa7cca/image.png" width="600" hegiht="300" align=center /></html><h4 id="更多Grafana操作点击这里"><a href="#更多Grafana操作点击这里" class="headerlink" title="更多Grafana操作点击这里"></a><a href="http://docs.grafana.org/guides/getting_started/" target="_blank" rel="noopener">更多Grafana操作点击这里</a></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;jmeter 在调试脚本时，用的是gui界面，可以通过界面监控插件实时查看数据.但在真实测试中，我们往往用的的是非gui界面，这样可以避免界
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MockMVC</title>
    <link href="http://yoursite.com/2020/12/23/MockMVC/"/>
    <id>http://yoursite.com/2020/12/23/MockMVC/</id>
    <published>2020-12-23T12:34:01.008Z</published>
    <updated>2020-12-23T12:34:01.008Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MockMVC"><a href="#MockMVC" class="headerlink" title="MockMVC"></a>MockMVC</h3><blockquote><p>基于RESTful风格的SpringMVC的测试</p></blockquote><p>对于前后端分离的项目而言，无法直接从前端静态代码中测试接口的正确性，因此可以通过MockMVC来模拟HTTP请求。基于RESTful风格的SpringMVC的测试，我们可以测试完整的Spring MVC流程，即从URL请求到控制器处理，再到视图渲染都可以测试。</p><h5 id="入门示例"><a href="#入门示例" class="headerlink" title="入门示例"></a>入门示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class">    @<span class="title">AutoConfigureMockMvc</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">class</span> <span class="title">CourseControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">            mockMvc.perform(</span><br><span class="line">                    <span class="comment">//构造一个post请求</span></span><br><span class="line">                    MockMvcRequestBuilders.post(<span class="string">"/hello"</span>)</span><br><span class="line">                    .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">            <span class="comment">//andExpect，添加ResultMathcers验证规则，验证控制器执行完成后结果是否正确，【这是一个断言】</span></span><br><span class="line">            .andExpect(MockMvcResultMatchers.status().is(<span class="number">200</span>))</span><br><span class="line">            .andExpect(MockMvcResultMatchers.content().contentType(MediaType.APPLICATION_JSON_UTF8))</span><br><span class="line">            <span class="comment">//假定返回的结果中，期望为hello，并给出期望值和实际值</span></span><br><span class="line">            .andExpect(MockMvcResultMatchers.content().string(<span class="string">"hello"</span>))</span><br><span class="line">            <span class="comment">//添加ResultHandler结果处理器，比如调试时 打印结果(print方法)到控制台</span></span><br><span class="line">            .andDo(print())</span><br><span class="line">            <span class="comment">//返回相应的MvcResult</span></span><br><span class="line">            .andReturn();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="MockMvcBuilder"><a href="#MockMvcBuilder" class="headerlink" title="MockMvcBuilder"></a>MockMvcBuilder</h4><p>MockMvcBuilder是用来构造MockMvc的构造器，其主要有两个实现：StandaloneMockMvcBuilder和DefaultMockMvcBuilder，分别对应两种测试方式，即独立安装和集成Web环境测试（此种方式并不会集成真正的web环境，而是通过相应的Mock API进行模拟测试，无须启动服务器）。对于我们来说直接使用静态工厂MockMvcBuilders创建即可。</p><h5 id="集成web环境方式"><a href="#集成web环境方式" class="headerlink" title="集成web环境方式"></a>集成web环境方式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class MockMvcTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private WebApplicationContext webApplicationContext;</span><br><span class="line">    private MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void setUp() &#123;</span><br><span class="line">        this.mockMvc &#x3D; MockMvcBuilders.webAppContextSetup(this.webApplicationContext).build();   &#x2F;&#x2F;构造MockMvc</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void courseListTest() throws Exception&#123;</span><br><span class="line">        MvcResult name&#x3D; mockMvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;hello&quot;))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(MockMvcResultMatchers.content().string(&quot;hello&quot;))</span><br><span class="line">                .andDo(print())</span><br><span class="line">                .andReturn();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="独立测试方式"><a href="#独立测试方式" class="headerlink" title="独立测试方式"></a>独立测试方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MockMvcBuilders.standaloneSetup(Object... controllers)：通过参数指定一组控制器，这样就不需要从上下文获取了；</span><br><span class="line">public class PricingExportResultsRestServiceTest &#123;</span><br><span class="line">    @InjectMocks</span><br><span class="line">    private PricingExportResultsRestService pricingExportResultsRestService;</span><br><span class="line">    @Mock</span><br><span class="line">    private ExportRateScheduleService exportRateScheduleService;</span><br><span class="line">    @Mock</span><br><span class="line">    private PricingUrlProvider pricingUrlProvider;</span><br><span class="line">    private MockMvc mockMvc;</span><br><span class="line">    @Before</span><br><span class="line">    public void setup() &#123;</span><br><span class="line">        MockitoAnnotations.initMocks(this);</span><br><span class="line">        mockMvc &#x3D; MockMvcBuilders.standaloneSetup(pricingExportResultsRestService).build();  &#x2F;&#x2F;构造MockMvc</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="主要是两个步骤："><a href="#主要是两个步骤：" class="headerlink" title="主要是两个步骤："></a>主要是两个步骤：</h5><ul><li>(1)首先自己创建相应的控制器，注入相应的依赖</li><li>(2)通过MockMvcBuilders.standaloneSetup模拟一个Mvc测试环境，通过build得到一个MockMvc</li></ul><h4 id="MockMvc使用规范："><a href="#MockMvc使用规范：" class="headerlink" title="MockMvc使用规范："></a>MockMvc使用规范：</h4><ul><li><p>准备测试环境</p></li><li><p>通过MockMvc执行请求</p></li><li><p>添加验证断言</p></li><li><p>添加结果处理器</p></li><li><p>得到MvcResult进行自定义断言/进行下一步的异步请求</p></li><li><p>卸载测试环境</p><h4 id="常用的API："><a href="#常用的API：" class="headerlink" title="常用的API："></a>常用的API：</h4></li><li><p>mockMvc.perform : 执行一个请求；</p></li><li><p>MockMvcRequestBuilders.get(“/user/1”) : 构造一个请求</p></li><li><p>ResultActions.andExpect : 添加执行完成后的断言</p></li><li><p>ResultActions.andDo : 添加一个结果处理器，表示要对结果做点什么事情，比如此处使用print()输出整个响应结果信息。</p></li><li><p>ResultActions.andReturn : 表示执行完成后返回相应的结果，通过MvcResult接收响应数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void courseListTest() throws Exception&#123;</span><br><span class="line">    MvcResult mvcResult&#x3D; mockMvc.perform(MockMvcRequestBuilders.get(&quot;&#x2F;hello&quot;))</span><br><span class="line">            .andExpect(status().isOk())</span><br><span class="line">            .andExpect(MockMvcResultMatchers.content().string(&quot;hello&quot;))</span><br><span class="line">            .andDo(print())</span><br><span class="line">            .andReturn();</span><br><span class="line">            </span><br><span class="line">    System.out.println(mvcResult.getResponse().getContentAsString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="RequestBuilder"><a href="#RequestBuilder" class="headerlink" title="RequestBuilder"></a>RequestBuilder</h5><blockquote><p>从名字可以看出，RequestBuilder用来构建请求的，其提供了一个方法buildRequest(ServletContext servletContext)用于构建MockHttpServletRequest；<br>其主要有两个子类, 即用来Mock客户端请求需要的所有数据。<br>MockHttpServletRequestBuilder<br>MockMultipartHttpServletRequestBuilder（如文件上传使用）<br>通过抽象类MockMvcRequestBuilders提供方法生成MockHttpServletRequestBuilder<br>MockMvcRequestBuilders提供的API<br>MockHttpServletRequestBuilder get(String urlTemplate, Object… urlVariables)：根据uri模板和uri变量值得到一个GET请求方式的MockHttpServletRequestBuilder；</p></blockquote><ul><li><p>如get(/user/{id}, 1L)；</p></li><li><p>MockHttpServletRequestBuilder post(String urlTemplate, Object… urlVariables)：同get类似，但是是POST方法；</p></li><li><p>MockHttpServletRequestBuilder put(String urlTemplate, Object… urlVariables)：同get类似，但是是PUT方法；</p></li><li><p>MockHttpServletRequestBuilder delete(String urlTemplate, Object… urlVariables) ：同get类似，但是是DELETE方法；</p></li><li><p>MockHttpServletRequestBuilder options(String urlTemplate, Object… urlVariables)：同get类似，但是是OPTIONS方法；</p></li><li><p>MockHttpServletRequestBuilder request(HttpMethod httpMethod, String urlTemplate, Object… urlVariables)： 提供自己的Http请求方法及uri模板和uri变量，如上API都是委托给这个API；</p></li><li><p>MockMultipartHttpServletRequestBuilder fileUpload(String urlTemplate, Object… urlVariables)：提供文件上传方式的请求，得到MockMultipartHttpServletRequestBuilder；</p></li><li><p>RequestBuilder asyncDispatch(final MvcResult mvcResult)：创建一个从启动异步处理的请求的MvcResult进行异步分派的RequestBuilder；</p></li></ul><h5 id="MockHttpServletRequestBuilder提供的API"><a href="#MockHttpServletRequestBuilder提供的API" class="headerlink" title="MockHttpServletRequestBuilder提供的API"></a>MockHttpServletRequestBuilder提供的API</h5><ul><li><p>MockHttpServletRequestBuilder header(String name, Object… values)/MockHttpServletRequestBuilder headers(HttpHeaders httpHeaders)：添加头信息；</p></li><li><p>MockHttpServletRequestBuilder contentType(MediaType mediaType)：指定请求的contentType头信息；</p></li><li><p>MockHttpServletRequestBuilder accept(MediaType… mediaTypes)/MockHttpServletRequestBuilder accept(String… mediaTypes)：指定请求的Accept头信息；</p></li><li><p>MockHttpServletRequestBuilder content(byte[] content)/MockHttpServletRequestBuilder content(String content)：指定请求Body体内容；</p></li><li><p>MockHttpServletRequestBuilder cookie(Cookie… cookies)：指定请求的Cookie；</p></li><li><p>MockHttpServletRequestBuilder locale(Locale locale)：指定请求的Locale；</p></li><li><p>MockHttpServletRequestBuilder characterEncoding(String encoding)：指定请求字符编码；</p></li><li><p>MockHttpServletRequestBuilder requestAttr(String name, Object value) ：设置请求属性数据；</p></li><li><p>MockHttpServletRequestBuilder sessionAttr(String name, Object value)/MockHttpServletRequestBuilder sessionAttrs(Map&lt;string, object=””&gt; sessionAttributes)：设置请求session属性数据；</p></li><li><p>MockHttpServletRequestBuilder flashAttr(String name, Object value)/MockHttpServletRequestBuilder flashAttrs(Map&lt;string, object=””&gt; flashAttributes)：指定请求的flash信息，比如重定向后的属性信息；</p></li><li><p>MockHttpServletRequestBuilder session(MockHttpSession session) ：指定请求的Session；</p></li><li><p>MockHttpServletRequestBuilder principal(Principal principal) ：指定请求的Principal；</p></li><li><p>MockHttpServletRequestBuilder contextPath(String contextPath) ：指定请求的上下文路径，必须以“/”开头，且不能以“/”结尾；</p></li><li><p>MockHttpServletRequestBuilder pathInfo(String pathInfo) ：请求的路径信息，必须以“/”开头；</p></li><li><p>MockHttpServletRequestBuilder secure(boolean secure)：请求是否使用安全通道；</p></li><li><p>MockHttpServletRequestBuilder with(RequestPostProcessor postProcessor)：请求的后处理器，用于自定义一些请求处理的扩展点；</p></li></ul><h5 id="MockMultipartHttpServletRequestBuilder提供的API"><a href="#MockMultipartHttpServletRequestBuilder提供的API" class="headerlink" title="MockMultipartHttpServletRequestBuilder提供的API"></a>MockMultipartHttpServletRequestBuilder提供的API</h5><ul><li><p>继承自MockHttpServletRequestBuilder，又提供了如下API<br>MockMultipartHttpServletRequestBuilder file(String name, byte[] content)/MockMultipartHttpServletRequestBuilder file(MockMultipartFile file) //指定要上传的文件；</p></li><li><p>ResultActions<br>调用MockMvc.perform(RequestBuilder requestBuilder)后将得到ResultActions<br>ResultActions提供了如下API</p></li><li><p>ResultActions andExpect(ResultMatcher matcher) // 添加验证断言来判断执行请求后的结果是否是预期的；<br>ResultActions andDo(ResultHandler handler) // 添加结果处理器，用于对验证成功后执行的动作，如输出下请求/结果信息用于调试；<br>MvcResult andReturn() // 返回验证成功后的MvcResult；用于自定义验证/下一步的异步处理；</p></li></ul><h5 id="ResultMatcher-验证器"><a href="#ResultMatcher-验证器" class="headerlink" title="ResultMatcher 验证器"></a>ResultMatcher 验证器</h5><p>ResultMatcher用来匹配执行完请求后的结果验证，其就一个match(MvcResult result)断言方法，如果匹配失败将抛出相应的异常；spring mvc测试框架提供了很多<strong><em>ResultMatchers来满足测试需求。注意这些</em></strong>ResultMatchers并不是ResultMatcher的子类，而是返回ResultMatcher实例的。Spring mvc测试框架为了测试方便提供了MockMvcResultMatchers静态工厂方法方便操作；</p><h5 id="MockMvcResultMatchers提供的API"><a href="#MockMvcResultMatchers提供的API" class="headerlink" title="MockMvcResultMatchers提供的API"></a>MockMvcResultMatchers提供的API</h5><ul><li><p>andlerResultMatchers handler()：请求的Handler验证器，比如验证处理器类型/方法名；此处的Handler其实就是处理请求的控制器；</p></li><li><p>RequestResultMatchers request()：得到RequestResultMatchers验证器；</p></li><li><p>ModelResultMatchers model()：得到模型验证器；</p></li><li><p>ViewResultMatchers view()：得到视图验证器；</p></li><li><p>FlashAttributeResultMatchers flash()：得到Flash属性验证；</p></li><li><p>StatusResultMatchers status()：得到响应状态验证器；</p></li><li><p>HeaderResultMatchers header()：得到响应Header验证器；</p></li><li><p>CookieResultMatchers cookie()：得到响应Cookie验证器；</p></li><li><p>ContentResultMatchers content()：得到响应内容验证器；</p></li><li><p>JsonPathResultMatchers jsonPath(String expression, Object … args)/ResultMatcher jsonPath  (String expression, Matcher matcher)：得到Json表达式验证器；</p></li><li><p>XpathResultMatchers xpath(String expression, Object… args)/XpathResultMatchers xpath(String expression, Map&lt;string, string=””&gt; namespaces, Object… args)：得到Xpath表达式验证器；</p></li><li><p>ResultMatcher forwardedUrl(final String expectedUrl)：验证处理完请求后转发的url（绝对匹配）；</p></li><li><p>ResultMatcher forwardedUrlPattern(final String urlPattern)：验证处理完请求后转发的url（Ant风格模式匹配，@since spring4）；</p></li><li><p>ResultMatcher redirectedUrl(final String expectedUrl)：验证处理完请求后重定向的url（绝对匹配）；</p></li><li><p>ResultMatcher redirectedUrlPattern(final String expectedUrl)：验证处理完请求后重定向的url（Ant风格模式匹配，@since spring4）</p></li></ul><h5 id="ResultHandler"><a href="#ResultHandler" class="headerlink" title="ResultHandler"></a>ResultHandler</h5><p>ResultHandler用于对处理的结果进行相应处理的，Spring mvc测试框架提供了MockMvcResultHandlers静态工厂方法</p><h5 id="MockMvcResultHandlers的API"><a href="#MockMvcResultHandlers的API" class="headerlink" title="MockMvcResultHandlers的API"></a>MockMvcResultHandlers的API</h5><ul><li>ResultHandler log()</li><li>ResultHandler print()</li><li>ResultHandler print(OutputStream stream)</li><li>ResultHandler print(Writer writer)</li></ul><h4 id="关系梳理"><a href="#关系梳理" class="headerlink" title="关系梳理"></a>关系梳理</h4><ul><li>MockMvcBuilder——&gt;通过MockMvcBuilders工厂方法生成MockMvcBuilder</li><li>MockMvc——&gt;通过MockMvc的perform方法接收RequestBuilder生成ResultActions</li><li>RequestBuilder——&gt;通过MockMvcRequestBuilders工厂get、post…方法生成RequestBuilder</li><li>ResultActions——&gt;andExpect()、andDo()返回ResultActions，链式操作；andReturn()产生MvcResult对象</li><li>ResultMatcher——&gt;ResultActions的andExpect()方法接收ResultMatcher，进行结果校验</li><li>ResultHandler——&gt;ResultActions的andDo()方法接收ResultHandler，对结果进行处理</li></ul><h4 id="常用案例"><a href="#常用案例" class="headerlink" title="常用案例"></a>常用案例</h4><h5 id="测试普通控制器"><a href="#测试普通控制器" class="headerlink" title="测试普通控制器"></a>测试普通控制器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(get(&quot;&#x2F;user&#x2F;&#123;id&#125;&quot;, 1)) &#x2F;&#x2F;执行请求  </span><br><span class="line">        .andExpect(model().attributeExists(&quot;user&quot;)) &#x2F;&#x2F;验证存储模型数据  </span><br><span class="line">        .andExpect(view().name(&quot;user&#x2F;view&quot;)) &#x2F;&#x2F;验证viewName  </span><br><span class="line">        .andExpect(forwardedUrl(&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;user&#x2F;view.jsp&quot;))&#x2F;&#x2F;验证视图渲染时forward到的jsp  </span><br><span class="line">        .andExpect(status().isOk())&#x2F;&#x2F;验证状态码  </span><br><span class="line">        .andDo(print()); &#x2F;&#x2F;输出MvcResult到控制台</span><br></pre></td></tr></table></figure><h5 id="得到MvcResult自定义验证"><a href="#得到MvcResult自定义验证" class="headerlink" title="得到MvcResult自定义验证"></a>得到MvcResult自定义验证</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MvcResult result &#x3D; mockMvc.perform(get(&quot;&#x2F;user&#x2F;&#123;id&#125;&quot;, 1))&#x2F;&#x2F;执行请求  </span><br><span class="line">        .andReturn(); &#x2F;&#x2F;返回MvcResult  </span><br><span class="line">Assert.assertNotNull(result.getModelAndView().getModel().get(&quot;user&quot;)); &#x2F;&#x2F;自定义断言   </span><br><span class="line"></span><br><span class="line">验证请求参数绑定到模型数据及Flash属性</span><br><span class="line">mockMvc.perform(post(&quot;&#x2F;user&quot;).param(&quot;name&quot;, &quot;zhang&quot;)) &#x2F;&#x2F;执行传递参数的POST请求(也可以post(&quot;&#x2F;user?name&#x3D;zhang&quot;))  </span><br><span class="line">            .andExpect(handler().handlerType(UserController.class)) &#x2F;&#x2F;验证执行的控制器类型  </span><br><span class="line">            .andExpect(handler().methodName(&quot;create&quot;)) &#x2F;&#x2F;验证执行的控制器方法名  </span><br><span class="line">            .andExpect(model().hasNoErrors()) &#x2F;&#x2F;验证页面没有错误  </span><br><span class="line">            .andExpect(flash().attributeExists(&quot;success&quot;)) &#x2F;&#x2F;验证存在flash属性  </span><br><span class="line">            .andExpect(view().name(&quot;redirect:&#x2F;user&quot;)); &#x2F;&#x2F;验证视图</span><br></pre></td></tr></table></figure><h5 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byte[] bytes &#x3D; new byte[] &#123;1, 2&#125;;  </span><br><span class="line">mockMvc.perform(fileUpload(&quot;&#x2F;user&#x2F;&#123;id&#125;&#x2F;icon&quot;, 1L).file(&quot;icon&quot;, bytes)) &#x2F;&#x2F;执行文件上传  </span><br><span class="line">        .andExpect(model().attribute(&quot;icon&quot;, bytes)) &#x2F;&#x2F;验证属性相等性  </span><br><span class="line">        .andExpect(view().name(&quot;success&quot;)); &#x2F;&#x2F;验证视图</span><br></pre></td></tr></table></figure><h5 id="JSON请求-响应验证"><a href="#JSON请求-响应验证" class="headerlink" title="JSON请求/响应验证"></a>JSON请求/响应验证</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String requestBody &#x3D; &quot;&#123;\&quot;id\&quot;:1, \&quot;name\&quot;:\&quot;zhang\&quot;&#125;&quot;;  </span><br><span class="line">    mockMvc.perform(post(&quot;&#x2F;user&quot;)  </span><br><span class="line">            .contentType(MediaType.APPLICATION_JSON).content(requestBody)  </span><br><span class="line">            .accept(MediaType.APPLICATION_JSON)) &#x2F;&#x2F;执行请求  </span><br><span class="line">            .andExpect(content().contentType(MediaType.APPLICATION_JSON)) &#x2F;&#x2F;验证响应contentType  </span><br><span class="line">            .andExpect(jsonPath(&quot;$.id&quot;).value(1)); &#x2F;&#x2F;使用Json path验证JSON 请参考http:&#x2F;&#x2F;goessner.net&#x2F;articles&#x2F;JsonPath&#x2F;   </span><br><span class="line">    String errorBody &#x3D; &quot;&#123;id:1, name:zhang&#125;&quot;;  </span><br><span class="line">    MvcResult result &#x3D; mockMvc.perform(post(&quot;&#x2F;user&quot;)  </span><br><span class="line">            .contentType(MediaType.APPLICATION_JSON).content(errorBody)  </span><br><span class="line">            .accept(MediaType.APPLICATION_JSON)) &#x2F;&#x2F;执行请求  </span><br><span class="line">            .andExpect(status().isBadRequest()) &#x2F;&#x2F;400错误请求  </span><br><span class="line">            .andReturn();   </span><br><span class="line">    Assert.assertTrue(HttpMessageNotReadableException.class.isAssignableFrom(result.getResolvedException().getClass()));&#x2F;&#x2F;错误的请求内容体</span><br></pre></td></tr></table></figure><h5 id="异步测试"><a href="#异步测试" class="headerlink" title="异步测试"></a>异步测试</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Callable  </span><br><span class="line">MvcResult result &#x3D; mockMvc.perform(get(&quot;&#x2F;user&#x2F;async1?id&#x3D;1&amp;name&#x3D;zhang&quot;)) &#x2F;&#x2F;执行请求  </span><br><span class="line">        .andExpect(request().asyncStarted())  </span><br><span class="line">        .andExpect(request().asyncResult(CoreMatchers.instanceOf(User.class))) &#x2F;&#x2F;默认会等10秒超时  </span><br><span class="line">        .andReturn();  </span><br><span class="line">    </span><br><span class="line">mockMvc.perform(asyncDispatch(result))  </span><br><span class="line">        .andExpect(status().isOk())  </span><br><span class="line">        .andExpect(content().contentType(MediaType.APPLICATION_JSON))  </span><br><span class="line">        .andExpect(jsonPath(&quot;$.id&quot;).value(1));</span><br></pre></td></tr></table></figure><h5 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h5><pre><code>mockMvc = webAppContextSetup(wac)          .defaultRequest(get(&quot;/user/1&quot;).requestAttr(&quot;default&quot;, true)) //默认请求 如果其是Mergeable类型的，会自动合并的哦mockMvc.perform中的RequestBuilder          .alwaysDo(print())  //默认每次执行请求后都做的动作          .alwaysExpect(request().attribute(&quot;default&quot;, true)) //默认每次执行后进行验证的断言          .build();  mockMvc.perform(get(&quot;/user/1&quot;))          .andExpect(model().attributeExists(&quot;user&quot;));</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MockMVC&quot;&gt;&lt;a href=&quot;#MockMVC&quot; class=&quot;headerlink&quot; title=&quot;MockMVC&quot;&gt;&lt;/a&gt;MockMVC&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;基于RESTful风格的SpringMVC的测试&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MySQL死锁分析</title>
    <link href="http://yoursite.com/2020/12/23/MySQL%E6%AD%BB%E9%94%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/12/23/MySQL%E6%AD%BB%E9%94%81%E5%88%86%E6%9E%90/</id>
    <published>2020-12-23T12:34:01.008Z</published>
    <updated>2020-12-23T12:34:01.008Z</updated>
    
    <content type="html"><![CDATA[<p>一、MySQL锁概述</p><p>数据库锁定机制简单来说，就是数据库为了保证数据的一致性，而使各种共享资源在被并发访问变得有序所设计的一种规则。MySQL各存储引擎使用了三种类型（级别）的锁定机制：表级锁定，行级锁定和页级锁定。</p><ol><li>基本锁</li></ol><ul><li>基本锁：共享锁(Shared Locks：S锁)与排他锁(Exclusive Locks：X锁)<br>mysql允许拿到S锁的事务读一行，允许拿到X锁的事务更新或删除一行。加了S锁的记录，允许其他事务再加S锁，不允许其他事务再加X锁；加了X锁的记录，不允许其他事务再加S锁或者X锁。</li></ul><ol start="2"><li>意向锁(Intention Locks)</li></ol><ul><li>InnoDB为了支持多粒度(表锁与行锁)的锁并存，引入意向锁。意向锁是表级锁，可分为意向共享锁(IS锁)和意向排他锁(IX锁)。</li></ul><ol start="3"><li>行锁</li></ol><ul><li>记录锁(Record Locks)<br>记录锁, 仅仅锁住索引记录的一行。单条索引记录上加锁，record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。所以说当一条sql没有走任何索引时，那么将会在每一条聚集索引后面加X锁，这个类似于表锁，但原理上和表锁应该是完全不同的。</li><li>间隙锁(Gap Locks)</li></ul><ol><li>区间锁, 仅仅锁住一个索引区间(开区间)。在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。</li><li>next-key锁(Next-Key Locks)<br>next key锁有两层含义，一是对当前记录加X锁，防止记录被并发修改，同时锁住记录之前的GAP，<br>防止有新的记录插入到此记录之前。<br>record lock + gap lock, 左开右闭区间。</li></ol><ul><li><p>插入意向锁(Insert Intention Locks)<br> Gap Lock中存在一种插入意向锁（Insert Intention Lock），在insert操作时产生。在多事务同时写入不同数据至同一索引间隙的时候，并不需要等待其他事务完成，不会发生锁等待。假设有一个记录索引包含键值4和7，不同的事务分别插入5和6，每个事务都会产生一个加在4-7之间的插入意向锁，获取在插入行上的排它锁，但是不会被互相锁住，因为数据行并不冲突。</p></li><li><p>实务的隔离级别</p><pre><code>级别概述   由高到低① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。③ Read committed (读已提交)：可避免脏读的发生。④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</code></pre></li></ul><hr><p>二、死锁实例一</p><pre><code>org.springframework.dao.DeadlockLoserDataAccessException:### Error updating database.  Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException: Deadlock found when trying to get lock; try restarting transaction### The error may involve com.wacai.platform.push.core.dao.mapper.UserPushMapper.updateByExample-Inline### The error occurred while setting parameters### SQL: UPDATE user_push  SET userId = ?,uid = ?,deviceId = ?,app = ?,channelType = ?,pushId = ?,version = ?,mc = ?,platform = ?,system_type = ?,createTime = ?,lastModTime = ? WHERE (  pushId = ? )### Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException: Deadlock found when trying to get lock; try restarting transaction; SQL []; Deadlock found when trying to get lock; try restarting transaction; nested exception is com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException: Deadlock found when trying to get lock; try restarting transaction    at org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator.doTranslate(SQLErrorCodeSQLExceptionTranslator.java:263)    at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:73)    at org.mybati</code></pre><ul><li><p>这种日志出现时  我们可以分析原因可能就是数据库锁造成，我们可以查看数据库是否有死锁日志，如果有进行分析找到原因。</p></li><li><p>查看数据库实务的隔离级别命令    </p><pre><code>select @@tx_isolation;此案例隔离级别为RC级别</code></pre></li><li><p>查看死锁命令</p><pre><code>SHOW ENGINE INNODB STATUS;</code></pre></li></ul><ul><li><p>死锁日志</p><pre><code>--------------------------LATEST DETECTED DEADLOCK------------------------2018-05-21 11:56:51 7fbbcf073700*** (1) TRANSACTION:TRANSACTION 35686607206, ACTIVE 0 sec starting index readmysql tables in use 1, locked 1#这行表示事务5686607206 正在使用1个表，且涉及锁的表有1个LOCK WAIT 2 lock struct(s), heap size 360, 1 row lock(s)#这行表示在等待两把锁，占用内存360字节，涉及1行记录，如果事务已经锁定了几行数据，这里将会有一行信息显示出锁定结构的数目（注意，这跟行锁是两回事）和堆大小，堆的大小指的是为了持有这些行锁而占用的内存大小，Innodb是用一种特殊的位图表来实现行锁的，从理论上讲，它可将每一个锁定的行表示为一个比特，经测试显示，每个锁通常不超过4比特MySQL thread id 17625650, OS thread handle 0x7fbbabfff700, query id 3324702142 192.168.3.118 qa_conn updating#这行表示该事务的线程ID信息，操作系统句柄信息，连接来源、用户DELETE FROM user_push  WHERE (  pushId = &apos;1234567&apos; )#这行表示事务涉及的SQL*** (1) WAITING FOR THIS LOCK TO BE GRANTED:#这行信息表示第一个事务正在等待锁被授予RECORD LOCKS space id 61173 page no 55058 n bits 424 index `uk_pushId` of table `wac_members`.`user_push` trx id 35686607206 lock_mode X locks rec but not gap waiting#这行信息表示等待的锁是一个record lock，空间id是61173，页编号为55058，大概位置在页的424位处，锁发生在表`wac_members`.`user_push的主键上，是一个X锁，但是不是gap lock。 waiting表示正在等待锁*** (2) TRANSACTION:TRANSACTION 35686607204, ACTIVE 0 sec inserting, thread declared inside InnoDB 5000mysql tables in use 1, locked 14 lock struct(s), heap size 1184, 4 row lock(s), undo log entries 2MySQL thread id 17625649, OS thread handle 0x7fbbcf073700, query id 3324702145 192.168.3.118 qa_conn updateINSERT INTO user_push  ( id,userId,uid,deviceId,app,channelType,pushId,version,mc,platform,system_type,createTime,lastModTime ) VALUES( null,null,0,&apos;1&apos;,3,4,&apos;1234567&apos;,&apos;111&apos;,&apos;1&apos;,41,&apos;OTHER&apos;,null,null )*** (2) HOLDS THE LOCK(S):RECORD LOCKS space id 61173 page no 55058 n bits 424 index `uk_pushId` of table `wac_members`.`user_push` trx id 35686607204 lock_mode X locks rec but not gap*** (2) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 61173 page no 55058 n bits 424 index `uk_pushId` of table `wac_members`.`user_push` trx id 35686607204 lock mode S waiting*** WE ROLL BACK TRANSACTION (1)</code></pre></li><li><p>在查看了很多文档及补充了知识(这部分会在最后介绍到，包括锁，死锁的各种场景，事务等知识)之后发现,具体到这条记录死锁的产生原因如下：<br> 从日志里我们可以看到事务1当前正在执行DELETE FROM user_push WHERE ( pushId = ‘1234567’ )，该条语句正在申请索引uk_pushId的X锁，所以提示lock_mode X waiting。</p><p> 从日志的HOLDS THE LOCKS(S)块中我们可以看到事务2持有索引push_id的X锁，并且是记录锁（Record Lock）。</p><p> 从日志的WAITING FOR THIS LOCK TO BE GRANTED块中我们可以看到事务2正在申请S锁，也就是共享锁。该锁是INSERT INTO user_push ( id,userId,uid,deviceId,app,channelType,pushId,version,mc,platform,system_type,createTime,lastModTime ) VALUES( null,null,0,’1’,3,4,’1234567’,’111’,’1’,41,’OTHER’,null,null )语句申请的。insert语句在普通情况下是会申请排他锁，也就是X锁，但是这里出现了S锁。这是因为push_id字段是一个唯一索引，所以insert语句会在插入前进行一次duplicate key的检查，为了使这次检查成功，需要申请S锁防止其他事务对push_id字段进行修改。</p><p> 那么为什么该S锁会失败呢？这是对同一个字段的锁的申请是需要排队的。S锁前面还有一个未申请成功的X锁，所以S锁必须等待，所以形成了循环等待，死锁出现了</p></li></ul><table><thead><tr><th>步骤</th><th>实务1</th><th>实务2</th></tr></thead><tbody><tr><td>1</td><td></td><td>begin</td></tr><tr><td>2</td><td></td><td>delete;执行成功，实务2占有pushid=1234567的X锁，类型为记忆锁。</td></tr><tr><td>3</td><td>begin</td><td></td></tr><tr><td>4</td><td>DELETE FROM user_push  WHERE (  pushId =’1234567’)</td><td></td></tr><tr><td>5</td><td>出现死锁，实务一权重较小，所以回滚</td><td>install；由于push_id字段建立唯一索引，所以需要申请S锁以便检查duplicate key，由于插入的A的之是2，所以排在X锁后面。但是前面的X锁的申请只有在实务2commit或者rollback只有才能成功，此时形成了循环等待，死锁产生。</td></tr></tbody></table><hr><ul><li><p>死锁案例二</p></li><li><p>此案例隔离级别为RR</p></li><li><p>死锁日志</p><pre><code>2018-05-22 12:47:40 7efdf9dec700InnoDB: transactions deadlock detected, dumping detailed information.2018-05-22 12:47:40 7efdf9dec700*** (1) TRANSACTION:TRANSACTION 4228123807, ACTIVE 0 sec starting index readmysql tables in use 1, locked 1LOCK WAIT 2 lock struct(s), heap size 360, 1 row lock(s)MySQL thread id 6949098, OS thread handle 0x7efb8f078700, query id 7126778404 10.1.96.139 wacuser updatingDELETE FROM user_push  WHERE (  pushId = &apos;63a4ba7bd19068068631850df110605f9053de9ae77d7d27e5041d25592aa4bf&apos; )*** (1) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 108 page no 11828 n bits 288 index `uk_pushId` of table `push_sharding001`.`user_push` trx id 4228123807 lock_mode X waiting*** (2) TRANSACTION:TRANSACTION 4228123799, ACTIVE 0 sec starting index read, thread declared inside InnoDB 1mysql tables in use 1, locked 13 lock struct(s), heap size 1184, 2 row lock(s)MySQL thread id 6945902, OS thread handle 0x7efdf9dec700, query id 7126778393 10.1.96.109 wacuser updatingDELETE FROM user_push  WHERE (  pushId = &apos;63a4ba7bd19068068631850df110605f9053de9ae77d7d27e5041d25592aa4bf&apos; )*** (2) HOLDS THE LOCK(S):RECORD LOCKS space id 108 page no 11828 n bits 288 index `uk_pushId` of table `push_sharding001`.`user_push` trx id 4228123799 lock_mode X locks rec but not gap*** (2) WAITING FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 108 page no 11828 n bits 288 index `uk_pushId` of table `push_sharding001`.`user_push` trx id 4228123799 lock_mode X waiting*** WE ROLL BACK TRANSACTION (1)</code></pre></li><li><p>初步分析</p><p>  并发事务，每个事务只有一条SQL语句：给定唯一的二级索引键值，删除一条记录。每个事务，最多只会删除一条记录，为什么会产生死锁？这绝对是不可能的。但是，事实上，却真的是发生了死锁。产生死锁的两个事务，删除的是同一条记录，这应该是死锁发生的一个潜在原因，但是，即使是删除同一条记录，从原理上来说，也不应该产生死锁。因此，经过初步分析，这个死锁是不可能产生的。这个结论，远远不够！</p></li><li><p>Delete操作的加锁逻辑</p></li></ul><pre><code>在《MySQL加锁处理分析》一文中，我详细分析了各种SQL语句对应的加锁逻辑。例如：Delete语句，内部就包含一个当前读(加锁读)，然后通过当前读返回的记录，调用Delete操作进行删除。在此文的 组合六：id唯一索引+RR 中，可以看到，RR隔离级别下，针对于满足条件的查询记录，会对记录加上排它锁(X锁)，但是并不会锁住记录之前的GAP(no gap lock)。对应到此文上面的死锁例子，事务2所持有的锁，是一把记录上的排它锁，但是没有锁住记录前的GAP(lock_mode X locks rec but not gap)，与我之前的加锁分析一致。在《MySQL加锁处理分析》一文中的 组合七：id非唯一索引+RR 部分的最后，我还提出了一个问题：如果组合五、组合六下，针对SQL：select * from t1 where id = 10 for update; 第一次查询，没有找到满足查询条件的记录，那么GAP锁是否还能够省略？针对此问题，参与的朋友在做过试验之后，给出的正确答案是：此时GAP锁不能省略，会在第一个不满足查询条件的记录上加GAP锁，防止新的满足条件的记录插入。以上两个加锁策略，都是正确的。以上两个策略，分别对应的是：1） 唯一索引上满足查询条件的记录存在并且有效；2）唯一索引上满足查询条件的记录不存在。但是，除了这两个之外，其实还有第三种：3）唯一索引上满足查询条件的记录存在但是无效。众所周知，InnoDB上删除一条记录，并不是真正意义上的物理删除，而是将记录标识为删除状态。(注：这些标识为删除状态的记录，后续会由后台的Purge操作进行回收，物理删除。但是，删除状态的记录会在索引中存放一段时间。) 在RR隔离级别下，唯一索引上满足查询条件，但是却是删除记录，如何加锁？InnoDB在此处的处理策略与前两种策略均不相同，或者说是前两种策略的组合：对于满足条件的删除记录，InnoDB会在记录上加next key lock X(对记录本身加X锁，同时锁住记录前的GAP，防止新的满足条件的记录插入。) Unique查询，三种情况，对应三种加锁策略，总结如下：找到满足条件的记录，并且记录有效，则对记录加X锁，No Gap锁(lock_mode X locks rec but not gap)；找到满足条件的记录，但是记录无效(标识为删除的记录)，则对记录加next key锁(同时锁住记录本身，以及记录之前的Gap：lock_mode X);未找到满足条件的记录，则对第一个不满足条件的记录加Gap锁，保证没有满足条件的记录插入(locks gap before rec)；此处，我们看到了next key锁，是否很眼熟？对了，前面死锁中事务1，事务2处于等待状态的锁，均为next key锁。明白了这三个加锁策略，其实构造一定的并发场景，死锁的原因已经呼之欲出。但是，还有一个前提策略需要介绍，那就是InnoDB内部采用的死锁预防策略。</code></pre><ul><li><p>剖析死锁的成因</p><p>  做了这么多铺垫，有了Delete操作的3种加锁逻辑、InnoDB的死锁预防策略等准备知识之后，再回过头来分析本文最初提到的死锁问题，就会手到拈来，事半而功倍。</p><p>  首先，假设user_push中只有一条记录：(1, ‘aaa’, ‘data’)。三个并发事务，同时执行以下的这条SQL：</p><p>  DELETE FROM user_push  WHERE (  pushId = ‘aaa’ )；</p><p>  并且产生了以下的并发执行逻辑，就会产生死锁：<br>  事务0：DELETE FROM user_push  WHERE (  pushId = ‘aaa’ )；<br>  事务1：DELETE FROM user_push  WHERE (  pushId = ‘aaa’ )；<br>  事务2：DELETE FROM user_push  WHERE (  pushId = ‘aaa’ )；</p></li></ul><table><thead><tr><th>步骤</th><th>事务1</th><th>事务2</th><th>事务3</th></tr></thead><tbody><tr><td>1</td><td>在pushId索引上，对pushId进行加锁（）lock_mode X rec but not gap</td><td></td><td></td></tr><tr><td>2</td><td></td><td></td><td>在pushId索引上，对pushId进行加锁（）lock_mode X rec but not gap</td></tr><tr><td>此时需要等待，因此释放页面锁，等待记录锁</td><td></td><td></td><td></td></tr><tr><td>3</td><td>进行删除操作，将索引上的记录标识为删除状态</td><td></td><td></td></tr><tr><td>4</td><td>事务0提交，释放记录锁</td><td></td><td></td></tr><tr><td>5</td><td></td><td></td><td>事务2在事务0提交后，成功获取 (lock_mode X not gap)记录锁，此时,由于此锁是在页面锁之后获取，记录可能已经被修改，因此需要restart，重新获取记录状态</td></tr><tr><td>6</td><td></td><td>事务1持有页面锁，读取到对应的记录，发现满足条件的记录存在，但为删除状态的jia</td><td></td></tr><tr><td>7</td><td></td><td></td><td></td></tr><tr><td>8</td><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、MySQL锁概述&lt;/p&gt;
&lt;p&gt;数据库锁定机制简单来说，就是数据库为了保证数据的一致性，而使各种共享资源在被并发访问变得有序所设计的一种规则。MySQL各存储引擎使用了三种类型（级别）的锁定机制：表级锁定，行级锁定和页级锁定。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基本锁&lt;/li&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java8-stream</title>
    <link href="http://yoursite.com/2020/05/26/java8-stream/"/>
    <id>http://yoursite.com/2020/05/26/java8-stream/</id>
    <published>2020-05-26T04:12:57.000Z</published>
    <updated>2020-12-23T12:34:01.009Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么需要-Stream"><a href="#为什么需要-Stream" class="headerlink" title="为什么需要 Stream"></a>为什么需要 Stream</h3><p>Stream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。</p><h3 id="什么是聚合操作"><a href="#什么是聚合操作" class="headerlink" title="什么是聚合操作"></a>什么是聚合操作</h3><p>在传统的 J2EE 应用中，Java 代码经常不得不依赖于关系型数据库的聚合操作来完成诸如：</p><p>客户每月平均消费金额<br>最昂贵的在售商品<br>本周完成的有效订单（排除了无效的）<br>取十个数据样本作为首页推荐<br>这类的操作。</p><p>但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离 RDBMS，或者以底层返回的数据为基础进行更上层的数据统计。而 Java 的集合 API 中，仅仅有极少量的辅助型方法，更多的时候是程序员需要用 Iterator 来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。在 Java 7 中，如果要发现 type 为 grocery 的所有交易，然后返回以交易值降序排序好的交易 ID 集合，我们需要这样写：</p><h4 id="清单-1-Java-7-的排序、取值实现"><a href="#清单-1-Java-7-的排序、取值实现" class="headerlink" title="清单 1. Java 7 的排序、取值实现"></a>清单 1. Java 7 的排序、取值实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Transaction&gt; groceryTransactions &#x3D; new Arraylist&lt;&gt;();</span><br><span class="line">for(Transaction t: transactions)&#123;</span><br><span class="line"> if(t.getType() &#x3D;&#x3D; Transaction.GROCERY)&#123;</span><br><span class="line"> groceryTransactions.add(t);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(groceryTransactions, new Comparator()&#123;</span><br><span class="line"> public int compare(Transaction t1, Transaction t2)&#123;</span><br><span class="line"> return t2.getValue().compareTo(t1.getValue());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line">List&lt;Integer&gt; transactionIds &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">for(Transaction t: groceryTransactions)&#123;</span><br><span class="line"> transactionsIds.add(t.getId());</span><br><span class="line">&#125;</span><br><span class="line">而在 Java 8 使用 Stream，代码更加简洁易读；而且使用并发模式，程序执行速度更快。</span><br></pre></td></tr></table></figure><h4 id="清单-2-Java-8-的排序、取值实现"><a href="#清单-2-Java-8-的排序、取值实现" class="headerlink" title="清单 2. Java 8 的排序、取值实现"></a>清单 2. Java 8 的排序、取值实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; transactionsIds &#x3D; transactions.parallelStream().</span><br><span class="line"> filter(t -&gt; t.getType() &#x3D;&#x3D; Transaction.GROCERY).</span><br><span class="line"> sorted(comparing(Transaction::getValue).reversed()).</span><br><span class="line"> map(Transaction::getId).</span><br><span class="line"> collect(toList());</span><br></pre></td></tr></table></figure><h2 id="Stream-总览"><a href="#Stream-总览" class="headerlink" title="Stream 总览"></a>Stream 总览</h2><h3 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h3><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</p><p>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</p><p>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下：</p><ul><li>1.0-1.4 中的 java.lang.Thread</li><li>5.0 中的 java.util.concurrent</li><li>6.0 中的 Phasers 等</li><li>7.0 中的 Fork/Join 框架</li><li>8.0 中的 Lambda</li></ul><p>Stream 的另外一大特点是，数据源本身可以是无限的。</p><h3 id="流的构成"><a href="#流的构成" class="headerlink" title="流的构成"></a>流的构成</h3><p>当我们使用一个流的时候，通常包括三个基本步骤：</p><p>获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。</p><h5 id="图-1-流管道-Stream-Pipeline-的构成"><a href="#图-1-流管道-Stream-Pipeline-的构成" class="headerlink" title="图 1. 流管道 (Stream Pipeline) 的构成"></a>图 1. 流管道 (Stream Pipeline) 的构成</h5><p><img src="http://git.caimi-inc.com/Platform/push/uploads/7027bcb36144c4e9d6763888933953bc/img001.png" alt="img001"></p><h5 id="有多种方式生成-Stream-Source："><a href="#有多种方式生成-Stream-Source：" class="headerlink" title="有多种方式生成 Stream Source："></a>有多种方式生成 Stream Source：</h5><ul><li><p>从 Collection 和数组</p><ul><li>Collection.stream()</li><li>Collection.parallelStream()</li><li>Arrays.stream(T array) or Stream.of()</li></ul></li><li><p>从 BufferedReader</p><ul><li>java.io.BufferedReader.lines()</li></ul></li><li><p>静态工厂</p><ul><li>java.util.stream.IntStream.range()</li><li>java.nio.file.Files.walk()</li></ul></li><li><p>自己构建</p><ul><li>java.util.Spliterator</li></ul></li><li><p>其它</p><ul><li>Random.ints()</li><li>BitSet.stream()</li><li>Pattern.splitAsStream(java.lang.CharSequence)</li><li>JarFile.stream()<h5 id="流的操作类型分为两种："><a href="#流的操作类型分为两种：" class="headerlink" title="流的操作类型分为两种："></a>流的操作类型分为两种：</h5></li></ul></li><li><ol><li>Intermediate：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</li></ol></li><li><ol start="2"><li>Terminal：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</li></ol></li></ul><p>在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。</p><p>还有一种操作被称为 short-circuiting。用以指：</p><ul><li>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。</li><li>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。<br>当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。</li></ul><h4 id="清单-3-一个流操作的示例"><a href="#清单-3-一个流操作的示例" class="headerlink" title="清单 3. 一个流操作的示例"></a>清单 3. 一个流操作的示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int sum &#x3D; widgets.stream()</span><br><span class="line"> .filter(w -&gt; w.getColor() &#x3D;&#x3D; RED)</span><br><span class="line"> .mapToInt(w -&gt; w.getWeight())</span><br><span class="line"> .sum();</span><br></pre></td></tr></table></figure><ul><li>test<br>stream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据筛选和转换，最后一个 sum() 为 terminal 操作，对符合条件的全部小物件作重量求和。</li></ul><h2 id="流的使用详解"><a href="#流的使用详解" class="headerlink" title="流的使用详解"></a>流的使用详解</h2><p>简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。</p><h2 id="流的构造与转换"><a href="#流的构造与转换" class="headerlink" title="流的构造与转换"></a>流的构造与转换</h2><p>下面提供最常见的几种构造 Stream 的样例。</p><h4 id="清单-4-构造流的几种常见方法"><a href="#清单-4-构造流的几种常见方法" class="headerlink" title="清单 4. 构造流的几种常见方法"></a>清单 4. 构造流的几种常见方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. Individual values</span><br><span class="line">Stream stream &#x3D; Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">&#x2F;&#x2F; 2. Arrays</span><br><span class="line">String [] strArray &#x3D; new String[] &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;;</span><br><span class="line">stream &#x3D; Stream.of(strArray);</span><br><span class="line">stream &#x3D; Arrays.stream(strArray);</span><br><span class="line">&#x2F;&#x2F; 3. Collections</span><br><span class="line">List&lt;String&gt; list &#x3D; Arrays.asList(strArray);</span><br><span class="line">stream &#x3D; list.stream();</span><br></pre></td></tr></table></figure><p>需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream：</p><p>IntStream、LongStream、DoubleStream。当然我们也可以用 Stream<Integer>、Stream<Long> &gt;、Stream<Double>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。</p><p>Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。</p><p>清单 5. 数值流的构造</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntStream.of(new int[]&#123;1, 2, 3&#125;).forEach(System.out::println);</span><br><span class="line">IntStream.range(1, 3).forEach(System.out::println);</span><br><span class="line">IntStream.rangeClosed(1, 3).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="清单-6-流转换为其它数据结构"><a href="#清单-6-流转换为其它数据结构" class="headerlink" title="清单 6. 流转换为其它数据结构"></a>清单 6. 流转换为其它数据结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. Array</span><br><span class="line">String[] strArray1 &#x3D; stream.toArray(String[]::new);</span><br><span class="line">&#x2F;&#x2F; 2. Collection</span><br><span class="line">List&lt;String&gt; list1 &#x3D; stream.collect(Collectors.toList());</span><br><span class="line">List&lt;String&gt; list2 &#x3D; stream.collect(Collectors.toCollection(ArrayList::new));</span><br><span class="line">Set set1 &#x3D; stream.collect(Collectors.toSet());</span><br><span class="line">Stack stack1 &#x3D; stream.collect(Collectors.toCollection(Stack::new));</span><br><span class="line">&#x2F;&#x2F; 3. String</span><br><span class="line">String str &#x3D; stream.collect(Collectors.joining()).toString();</span><br></pre></td></tr></table></figure><p>一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。</p><h3 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h3><p>接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。</p><ul><li><p>Intermediate：<br>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</p></li><li><p>Terminal：<br>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</p></li><li><p>Short-circuiting：<br>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</p></li></ul><p>我们下面看一下 Stream 的比较典型用法。</p><h4 id="map-flatMap"><a href="#map-flatMap" class="headerlink" title="map/flatMap"></a>map/flatMap</h4><p>我们先来看 map。如果你熟悉 scala 这类函数式语言，对这个方法应该很了解，它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。</p><h4 id="清单-7-转换大写"><a href="#清单-7-转换大写" class="headerlink" title="清单 7. 转换大写"></a>清单 7. 转换大写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; output &#x3D; wordList.stream().</span><br><span class="line">map(String::toUpperCase).</span><br><span class="line">collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>这段代码把所有的单词转换为大写。</p><h4 id="清单-8-平方数"><a href="#清单-8-平方数" class="headerlink" title="清单 8. 平方数"></a>清单 8. 平方数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; nums &#x3D; Arrays.asList(1, 2, 3, 4);</span><br><span class="line">List&lt;Integer&gt; squareNums &#x3D; nums.stream().</span><br><span class="line">map(n -&gt; n * n).</span><br><span class="line">collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>这段代码生成一个整数 list 的平方数 {1, 4, 9, 16}。</p><p>从上面例子可以看出，map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。</p><h4 id="清单-9-一对多"><a href="#清单-9-一对多" class="headerlink" title="清单 9. 一对多"></a>清单 9. 一对多</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; inputStream &#x3D; Stream.of(</span><br><span class="line"> Arrays.asList(1),</span><br><span class="line"> Arrays.asList(2, 3),</span><br><span class="line"> Arrays.asList(4, 5, 6)</span><br><span class="line"> );</span><br><span class="line">Stream&lt;Integer&gt; outputStream &#x3D; inputStream.</span><br><span class="line">flatMap((childList) -&gt; childList.stream());</span><br></pre></td></tr></table></figure><p>flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。</p><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。</p><h4 id="清单-10-留下偶数"><a href="#清单-10-留下偶数" class="headerlink" title="清单 10. 留下偶数"></a>清单 10. 留下偶数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] sixNums &#x3D; &#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line">Integer[] evens &#x3D;</span><br><span class="line">Stream.of(sixNums).filter(n -&gt; n%2 &#x3D;&#x3D; 0).toArray(Integer[]::new);</span><br></pre></td></tr></table></figure><p>经过条件“被 2 整除”的 filter，剩下的数字为 {2, 4, 6}。</p><h4 id="清单-11-把单词挑出来"><a href="#清单-11-把单词挑出来" class="headerlink" title="清单 11. 把单词挑出来"></a>清单 11. 把单词挑出来</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; output &#x3D; reader.lines().</span><br><span class="line"> flatMap(line -&gt; Stream.of(line.split(REGEXP))).</span><br><span class="line"> filter(word -&gt; word.length() &gt; 0).</span><br><span class="line"> collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。</p><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。</p><h4 id="清单-12-打印姓名（forEach-和-pre-java8-的对比）"><a href="#清单-12-打印姓名（forEach-和-pre-java8-的对比）" class="headerlink" title="清单 12. 打印姓名（forEach 和 pre-java8 的对比）"></a>清单 12. 打印姓名（forEach 和 pre-java8 的对比）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Java 8</span><br><span class="line">roster.stream()</span><br><span class="line"> .filter(p -&gt; p.getGender() &#x3D;&#x3D; Person.Sex.MALE)</span><br><span class="line"> .forEach(p -&gt; System.out.println(p.getName()));</span><br><span class="line">&#x2F;&#x2F; Pre-Java 8</span><br><span class="line">for (Person p : roster) &#123;</span><br><span class="line"> if (p.getGender() &#x3D;&#x3D; Person.Sex.MALE) &#123;</span><br><span class="line"> System.out.println(p.getName());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。</p><p>但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。</p><p>另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。下面的代码是错误的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream.forEach(element -&gt; doOneThing(element));</span><br><span class="line">stream.forEach(element -&gt; doAnotherThing(element));</span><br></pre></td></tr></table></figure><p>相反，具有相似功能的 intermediate 操作 peek 可以达到上述目的。如下是出现在该 api javadoc 上的一个示例。</p><h4 id="清单-13-peek-对每个元素执行操作并返回一个新的-Stream"><a href="#清单-13-peek-对每个元素执行操作并返回一个新的-Stream" class="headerlink" title="清单 13. peek 对每个元素执行操作并返回一个新的 Stream"></a>清单 13. peek 对每个元素执行操作并返回一个新的 Stream</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;)</span><br><span class="line"> .filter(e -&gt; e.length() &gt; 3)</span><br><span class="line"> .peek(e -&gt; System.out.println(&quot;Filtered value: &quot; + e))</span><br><span class="line"> .map(String::toUpperCase)</span><br><span class="line"> .peek(e -&gt; System.out.println(&quot;Mapped value: &quot; + e))</span><br><span class="line"> .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。</p><h4 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h4><p>这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。</p><p>这里比较重点的是它的返回值类型：Optional。这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。</p><h4 id="清单-14-Optional-的两个用例"><a href="#清单-14-Optional-的两个用例" class="headerlink" title="清单 14. Optional 的两个用例"></a>清单 14. Optional 的两个用例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">String strA &#x3D; &quot; abcd &quot;, strB &#x3D; null;</span><br><span class="line">print(strA);</span><br><span class="line">print(&quot;&quot;);</span><br><span class="line">print(strB);</span><br><span class="line">getLength(strA);</span><br><span class="line">getLength(&quot;&quot;);</span><br><span class="line">getLength(strB);</span><br><span class="line">public static void print(String text) &#123;</span><br><span class="line"> &#x2F;&#x2F; Java 8</span><br><span class="line"> Optional.ofNullable(text).ifPresent(System.out::println);</span><br><span class="line"> &#x2F;&#x2F; Pre-Java 8</span><br><span class="line"> if (text !&#x3D; null) &#123;</span><br><span class="line"> System.out.println(text);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">public static int getLength(String text) &#123;</span><br><span class="line"> &#x2F;&#x2F; Java 8</span><br><span class="line">return Optional.ofNullable(text).map(String::length).orElse(-1);</span><br><span class="line"> &#x2F;&#x2F; Pre-Java 8</span><br><span class="line">&#x2F;&#x2F; return if (text !&#x3D; null) ? text.length() : -1;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>在更复杂的 if (xx != null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。</p><p>Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。</p><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于</p><p>Integer sum = integers.reduce(0, (a, b) -&gt; a+b); 或</p><p>Integer sum = integers.reduce(0, Integer::sum);</p><p>也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。</p><h4 id="清单-15-reduce-的用例"><a href="#清单-15-reduce-的用例" class="headerlink" title="清单 15. reduce 的用例"></a>清单 15. reduce 的用例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 字符串连接，concat &#x3D; &quot;ABCD&quot;</span><br><span class="line">String concat &#x3D; Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;).reduce(&quot;&quot;, String::concat); </span><br><span class="line">&#x2F;&#x2F; 求最小值，minValue &#x3D; -3.0</span><br><span class="line">double minValue &#x3D; Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); </span><br><span class="line">&#x2F;&#x2F; 求和，sumValue &#x3D; 10, 有起始值</span><br><span class="line">int sumValue &#x3D; Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);</span><br><span class="line">&#x2F;&#x2F; 求和，sumValue &#x3D; 10, 无起始值</span><br><span class="line">sumValue &#x3D; Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();</span><br><span class="line">&#x2F;&#x2F; 过滤，字符串连接，concat &#x3D; &quot;ace&quot;</span><br><span class="line">concat &#x3D; Stream.of(&quot;a&quot;, &quot;B&quot;, &quot;c&quot;, &quot;D&quot;, &quot;e&quot;, &quot;F&quot;).</span><br><span class="line"> filter(x -&gt; x.compareTo(&quot;Z&quot;) &gt; 0).</span><br><span class="line"> reduce(&quot;&quot;, String::concat);</span><br></pre></td></tr></table></figure><p>上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。</p><h4 id="limit-skip"><a href="#limit-skip" class="headerlink" title="limit/skip"></a>limit/skip</h4><p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。</p><h4 id="清单-16-limit-和-skip-对运行次数的影响"><a href="#清单-16-limit-和-skip-对运行次数的影响" class="headerlink" title="清单 16. limit 和 skip 对运行次数的影响"></a>清单 16. limit 和 skip 对运行次数的影响</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void testLimitAndSkip() &#123;</span><br><span class="line"> List&lt;Person&gt; persons &#x3D; new ArrayList();</span><br><span class="line"> for (int i &#x3D; 1; i &lt;&#x3D; 10000; i++) &#123;</span><br><span class="line"> Person person &#x3D; new Person(i, &quot;name&quot; + i);</span><br><span class="line"> persons.add(person);</span><br><span class="line"> &#125;</span><br><span class="line">List&lt;String&gt; personList2 &#x3D; persons.stream().</span><br><span class="line">map(Person::getName).limit(10).skip(3).collect(Collectors.toList());</span><br><span class="line"> System.out.println(personList2);</span><br><span class="line">&#125;</span><br><span class="line">private class Person &#123;</span><br><span class="line"> public int no;</span><br><span class="line"> private String name;</span><br><span class="line"> public Person (int no, String name) &#123;</span><br><span class="line"> this.no &#x3D; no;</span><br><span class="line"> this.name &#x3D; name;</span><br><span class="line"> &#125;</span><br><span class="line"> public String getName() &#123;</span><br><span class="line"> System.out.println(name);</span><br><span class="line"> return name;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">name1</span><br><span class="line">name2</span><br><span class="line">name3</span><br><span class="line">name4</span><br><span class="line">name5</span><br><span class="line">name6</span><br><span class="line">name7</span><br><span class="line">name8</span><br><span class="line">name9</span><br><span class="line">name10</span><br><span class="line">[name4, name5, name6, name7, name8, name9, name10]</span><br></pre></td></tr></table></figure><p>这是一个有 10，000 个元素的 Stream，但在 short-circuiting 操作 limit 和 skip 的作用下，管道中 map 操作指定的 getName() 方法的执行次数为 limit 所限定的 10 次，而最终返回结果在跳过前 3 个元素后只有后面 7 个返回。</p><p>有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate 操作有关：此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样。</p><h4 id="清单-17-limit-和-skip-对-sorted-后的运行次数无影响"><a href="#清单-17-limit-和-skip-对-sorted-后的运行次数无影响" class="headerlink" title="清单 17. limit 和 skip 对 sorted 后的运行次数无影响"></a>清单 17. limit 和 skip 对 sorted 后的运行次数无影响</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; persons &#x3D; new ArrayList();</span><br><span class="line"> for (int i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line"> Person person &#x3D; new Person(i, &quot;name&quot; + i);</span><br><span class="line"> persons.add(person);</span><br><span class="line"> &#125;</span><br><span class="line">List&lt;Person&gt; personList2 &#x3D; persons.stream().sorted((p1, p2) -&gt; </span><br><span class="line">p1.getName().compareTo(p2.getName())).limit(2).collect(Collectors.toList());</span><br><span class="line">System.out.println(personList2);</span><br></pre></td></tr></table></figure><p>上面的示例对清单 13 做了微调，首先对 5 个元素的 Stream 排序，然后进行 limit 操作。输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name2</span><br><span class="line">name1</span><br><span class="line">name3</span><br><span class="line">name2</span><br><span class="line">name4</span><br><span class="line">name3</span><br><span class="line">name5</span><br><span class="line">name4</span><br><span class="line">[stream.StreamDW$Person@816f27d, stream.StreamDW$Person@87aac27]</span><br></pre></td></tr></table></figure><p>即虽然最后的返回元素数量是 2，但整个管道中的 sorted 表达式执行次数没有像前面例子相应减少。</p><p>最后有一点需要注意的是，对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream。</p><h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><p>对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。我们对清单 14 进行优化：</p><h4 id="清单-18-优化：排序前进行-limit-和-skip"><a href="#清单-18-优化：排序前进行-limit-和-skip" class="headerlink" title="清单 18. 优化：排序前进行 limit 和 skip"></a>清单 18. 优化：排序前进行 limit 和 skip</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; persons &#x3D; new ArrayList();</span><br><span class="line"> for (int i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line"> Person person &#x3D; new Person(i, &quot;name&quot; + i);</span><br><span class="line"> persons.add(person);</span><br><span class="line"> &#125;</span><br><span class="line">List&lt;Person&gt; personList2 &#x3D; persons.stream().limit(2).sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).collect(Collectors.toList());</span><br><span class="line">System.out.println(personList2);</span><br></pre></td></tr></table></figure><p>结果会简单很多：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name2</span><br><span class="line">name1</span><br><span class="line">[stream.StreamDW$Person@6ce253f1, stream.StreamDW$Person@53d8d10a]</span><br></pre></td></tr></table></figure><p>当然，这种优化是有 business logic 上的局限性的：即不要求排序后再取值。</p><h4 id="min-max-distinct"><a href="#min-max-distinct" class="headerlink" title="min/max/distinct"></a>min/max/distinct</h4><p>min 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。</p><h4 id="清单-19-找出最长一行的长度"><a href="#清单-19-找出最长一行的长度" class="headerlink" title="清单 19. 找出最长一行的长度"></a>清单 19. 找出最长一行的长度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br &#x3D; new BufferedReader(new FileReader(&quot;c:\\SUService.log&quot;));</span><br><span class="line">int longest &#x3D; br.lines().</span><br><span class="line"> mapToInt(String::length).</span><br><span class="line"> max().</span><br><span class="line"> getAsInt();</span><br><span class="line">br.close();</span><br><span class="line">System.out.println(longest);</span><br></pre></td></tr></table></figure><p>下面的例子则使用 distinct 来找出不重复的单词。</p><h4 id="清单-20-找出全文的单词，转小写，并排序"><a href="#清单-20-找出全文的单词，转小写，并排序" class="headerlink" title="清单 20. 找出全文的单词，转小写，并排序"></a>清单 20. 找出全文的单词，转小写，并排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words &#x3D; br.lines().</span><br><span class="line"> flatMap(line -&gt; Stream.of(line.split(&quot; &quot;))).</span><br><span class="line"> filter(word -&gt; word.length() &gt; 0).</span><br><span class="line"> map(String::toLowerCase).</span><br><span class="line"> distinct().</span><br><span class="line"> sorted().</span><br><span class="line"> collect(Collectors.toList());</span><br><span class="line">br.close();</span><br><span class="line">System.out.println(words);</span><br></pre></td></tr></table></figure><h4 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h4><p>Stream 有三个 match 方法，从语义上说：</p><p>allMatch：Stream 中全部元素符合传入的 predicate，返回 true<br>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true<br>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true<br>它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。对清单 13 中的 Person 类稍做修改，加入一个 age 属性和 getAge 方法。</p><h4 id="清单-21-使用-Match"><a href="#清单-21-使用-Match" class="headerlink" title="清单 21. 使用 Match"></a>清单 21. 使用 Match</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; persons &#x3D; new ArrayList();</span><br><span class="line">persons.add(new Person(1, &quot;name&quot; + 1, 10));</span><br><span class="line">persons.add(new Person(2, &quot;name&quot; + 2, 21));</span><br><span class="line">persons.add(new Person(3, &quot;name&quot; + 3, 34));</span><br><span class="line">persons.add(new Person(4, &quot;name&quot; + 4, 6));</span><br><span class="line">persons.add(new Person(5, &quot;name&quot; + 5, 55));</span><br><span class="line">boolean isAllAdult &#x3D; persons.stream().</span><br><span class="line"> allMatch(p -&gt; p.getAge() &gt; 18);</span><br><span class="line">System.out.println(&quot;All are adult? &quot; + isAllAdult);</span><br><span class="line">boolean isThereAnyChild &#x3D; persons.stream().</span><br><span class="line"> anyMatch(p -&gt; p.getAge() &lt; 12);</span><br><span class="line">System.out.println(&quot;Any child? &quot; + isThereAnyChild);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">All are adult? false</span><br><span class="line">Any child? true</span><br></pre></td></tr></table></figure><p>进阶：自己生成流<br>Stream.generate</p><p>通过实现 Supplier 接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。把 Supplier 实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用 limit 之类的操作限制 Stream 大小。</p><h4 id="清单-22-生成-10-个随机整数"><a href="#清单-22-生成-10-个随机整数" class="headerlink" title="清单 22. 生成 10 个随机整数"></a>清单 22. 生成 10 个随机整数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Random seed &#x3D; new Random();</span><br><span class="line">Supplier&lt;Integer&gt; random &#x3D; seed::nextInt;</span><br><span class="line">Stream.generate(random).limit(10).forEach(System.out::println);</span><br><span class="line">&#x2F;&#x2F;Another way</span><br><span class="line">IntStream.generate(() -&gt; (int) (System.nanoTime() % 100)).</span><br><span class="line">limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>Stream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream 的每个元素值。这些都是维持状态信息的情形。</p><h4 id="清单-23-自实现-Supplier"><a href="#清单-23-自实现-Supplier" class="headerlink" title="清单 23. 自实现 Supplier"></a>清单 23. 自实现 Supplier</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(new PersonSupplier()).</span><br><span class="line">limit(10).</span><br><span class="line">forEach(p -&gt; System.out.println(p.getName() + &quot;, &quot; + p.getAge()));</span><br><span class="line">private class PersonSupplier implements Supplier&lt;Person&gt; &#123;</span><br><span class="line"> private int index &#x3D; 0;</span><br><span class="line"> private Random random &#x3D; new Random();</span><br><span class="line"> @Override</span><br><span class="line"> public Person get() &#123;</span><br><span class="line"> return new Person(index++, &quot;StormTestUser&quot; + index, random.nextInt(100));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">StormTestUser1, 9</span><br><span class="line">StormTestUser2, 12</span><br><span class="line">StormTestUser3, 88</span><br><span class="line">StormTestUser4, 51</span><br><span class="line">StormTestUser5, 22</span><br><span class="line">StormTestUser6, 28</span><br><span class="line">StormTestUser7, 81</span><br><span class="line">StormTestUser8, 51</span><br><span class="line">StormTestUser9, 4</span><br><span class="line">StormTestUser10, 76</span><br><span class="line">Stream.iterate</span><br></pre></td></tr></table></figure><p>iterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。</p><h4 id="清单-24-生成一个等差数列"><a href="#清单-24-生成一个等差数列" class="headerlink" title="清单 24. 生成一个等差数列"></a>清单 24. 生成一个等差数列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(0, n -&gt; n + 3).limit(10). forEach(x -&gt; System.out.print(x + &quot; &quot;));</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 3 6 9 12 15 18 21 24 27</span><br></pre></td></tr></table></figure><p>与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。</p><p>进阶：用 Collectors 来进行 reduction 操作<br>java.util.stream.Collectors 类的主要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。</p><p>groupingBy/partitioningBy</p><h4 id="清单-25-按照年龄归组"><a href="#清单-25-按照年龄归组" class="headerlink" title="清单 25. 按照年龄归组"></a>清单 25. 按照年龄归组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, List&lt;Person&gt;&gt; personGroups &#x3D; Stream.generate(new PersonSupplier()).</span><br><span class="line"> limit(100).</span><br><span class="line"> collect(Collectors.groupingBy(Person::getAge));</span><br><span class="line">Iterator it &#x3D; personGroups.entrySet().iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line"> Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons &#x3D; (Map.Entry) it.next();</span><br><span class="line"> System.out.println(&quot;Age &quot; + persons.getKey() + &quot; &#x3D; &quot; + persons.getValue().size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 code，首先生成 100 人的信息，然后按照年龄归组，相同年龄的人放到同一个 list 中，可以看到如下的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Age 0 &#x3D; 2</span><br><span class="line">Age 1 &#x3D; 2</span><br><span class="line">Age 5 &#x3D; 2</span><br><span class="line">Age 8 &#x3D; 1</span><br><span class="line">Age 9 &#x3D; 1</span><br><span class="line">Age 11 &#x3D; 2</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h4 id="清单-26-按照未成年人和成年人归组"><a href="#清单-26-按照未成年人和成年人归组" class="headerlink" title="清单 26. 按照未成年人和成年人归组"></a>清单 26. 按照未成年人和成年人归组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Person&gt;&gt; children &#x3D; Stream.generate(new PersonSupplier()).</span><br><span class="line"> limit(100).</span><br><span class="line"> collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; 18));</span><br><span class="line">System.out.println(&quot;Children number: &quot; + children.get(true).size());</span><br><span class="line">System.out.println(&quot;Adult number: &quot; + children.get(false).size());</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Children number: 23 </span><br><span class="line">Adult number: 77</span><br></pre></td></tr></table></figure><p>在使用条件“年龄小于 18”进行分组后可以看到，不到 18 岁的未成年人是一组，成年人是另外一组。partitioningBy 其实是一种特殊的 groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true) 和 get(false) 能即为全部的元素对象。</p><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>总之，Stream 的特性可以归纳为：</p><p>不是数据结构<br>它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。<br>它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。<br>所有 Stream 的操作必须以 lambda 表达式为参数<br>不支持索引访问<br>你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。<br>很容易生成数组或者 List<br>惰性化<br>很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。<br>Intermediate 操作永远是惰性化的。<br>并行能力<br>当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。<br>可以是无限的<br>集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;为什么需要-Stream&quot;&gt;&lt;a href=&quot;#为什么需要-Stream&quot; class=&quot;headerlink&quot; title=&quot;为什么需要 Stream&quot;&gt;&lt;/a&gt;为什么需要 Stream&lt;/h3&gt;&lt;p&gt;Stream 作为 Java 8 的一大亮点，它与 java
      
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
</feed>
